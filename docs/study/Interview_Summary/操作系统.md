# 操作系统面试知识点汇总

> 计算机网络面试题目整理，后续遇到好的问题会不断更新。
>
> 如有错误须更正，请联系1726977432@qq.com

---

* **1. 简述操作系统的四个特征？**
    * **并发**：指两个或多个事件在同一时间间隔内发生（并行：多个事件同一时间发生）。
    * **共享**：指资源共享，系统的资源可供内存中多个并发执行的进程共同使用。并且可细分为互斥共享（同一时间段只允许一个进程访问）与同时共享。
    * **虚拟**：指把一个物理上的实体变为若干个逻辑实体。（时分复用、空分复用）虚拟是操作系统管理系统资源的重要手段，可提高资源的利用率。
    * **异步**：在多道程序下，允许多个程序并发执行，但由于资源等因素的限制，程序的执行并不是一气呵成，而是以某种不可预知的速度推进。

* **2. 简述操作系统的主要功能？**
    * **处理机（进程）管理**：对处理机进行分配管理，由于多道程序环境下，处理机的分配和运行以进程为基本单位，因此可归纳为进程管理，包括进程控制、进程同步、进程通信、进程调度等。
    * **存储管理**：对多道程序的运行提供良好的环境，提高存储器的利用率，主要包括有内存分配、内存保护、地址映射、内存扩充等功能。
    * **设备管理**：主要负责内核和外围设备的数据交互，实质是对硬件的管理，主要包括有输入输出设备的分配、初始化、维护和回收等功能。
    * **文件管理**：涉及文件的逻辑组织和物理组织、目录结构和管理等，主要包括有文件存储空间的管理、目录管理、文件共享和保护等功能。
    * **作业管理**：负责人机交互、图形界面或系统任务的管理。

* **3. 简述操作系统两种处理器状态？**
    * **用户态（目态）**：CPU只能执行非特权指令
    * **核心态（管态）**：CPU可以执行任何指令，root
    * **分状态的原因**：
        + CPU将指令分为特权指令与非特权指令，为了防止用户能轻易对系统作出危险的操作，故在用户态时只能执行普通的指令。
    * **计算机如何标识CPU的状态**：
        + 使用程序字寄存器PSW中的某个标识位来标识当前处理器的状态，比如0为用户态，1为核心态。

* **4. 简述用户态与核心态如何相互切换？**
    * 用户态->核心态：系统调用、异常、外围设备中断。
        + **系统调用**：主动切换，例如fork就是一个系统调用。
        + **异常**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
        + **外围设备中断**：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。

* **5. 简述操作系统的中断机制？**
    * 中断机制的产生是为了提高多道程序并发执行的环境下CPU的利用率。
    * 中断是指在计算机执行程序的过程中，由于出现了某些特殊的事情，使得CPU暂停对程序的执行，转而执行处理这一事件的程序。等这些特殊的事件处理完成，再回去执行之前的程序。
    * **中断的分类**：
        + **内部异常中断**：指由计算机硬件异常或故障引起的中断。
        + **软中断**：指由程序中执行了引起中断的指令而造成的中断。
        + **外部中断**：由外部设备请求引起的中断。

* **6.	简述外中断和异常的区别？**
    * 外中断是由CPU执行指令以外的事件引起，如I/O完成中断、时钟中断等。
    * 异常是由CPU执行指令的内部事件引起，如非法操作码、地址越界、算数溢出等。

    > **相同点**：
    > * 都是由CPU发送给内核，由内核处理。
    > * 处理程序的流程设计是相似的。
    >
    > **不同点**：
    > * 产生源不同，异常由CPU产生，而中断由硬件设备产生。
    > * 内核需要根据是异常还是中断调用不同的处理程序。
    > * 中断不是时钟同步，意味着可能随时到来，而异常是CPU产生的，是时钟同步的。
    > * 当处理中断时，处于中断上下文，处理异常时，处于进程上下文。

* **7.	简述发生外中断的处理过程？**
    * 执行完每条指令后，CPU都会检查当前是否有来自外部的中断信号。
    * 如果检测到外部中断，则会先保护被中断进程的CPU现场，包括有程序状态字PSW、程序计数器PC、各种通用寄存器。
    * 根据中断信号类型转入相应的中断处理程序。
    * 恢复原进程的CPU环境并退出中断，返回原进程继续执行。

* **8.	简述对进程、线程、协程的认识？**
    * **进程的概念**：由程序段、数据段、PCB组成进程实体，一般把进程实体简称为进程。进程是进程实体的运行过程，是系统资源分配的最小单位。
    * **线程的概念**：线程是CPU调度的最小单位，线程的产生提高了系统的并发度，且同一进程下的线程共享同一套资源，包括全局变量、静态变量、指针、引用、文件，而各自独有栈。
    * **协程的概念**：协程是用户级的轻量线程，是线程内部调度的基本单位。并且协程的切换基本没有内核切换的开销，但同一时间只能单一协程执行操作。

* **9.	简述进程、线程、协程切换的开销？**
    * **进程**：需要切换虚拟地址空间，	切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大。
    * **线程**：切换时只需保存和设置少量寄存器内容，开销很小。
    * **协程**：直接操作栈基本没有内核切换的开销，可以不加锁的访问全局变量，无开销。

* **10.	简述进程、线程的区别和联系？**
    * **区别**：
        * 进程拥有自己独立的地址空间，线程没有。
        * 进程是资源分配的最小单位，而线程是CPU调度的最小单位。
        * 通信方式不同，进程间通信复杂，而同一进程下的线程间共享数据通信方便。
        * 进程进程上下文切换开销大，而线程开销小。
        * 一个进程挂掉了不会影响其它进程，而线程挂掉了会影响其它线程。
    * **联系**：
        * 一个线程只能属于一个进程，而一个进程可以拥有多个线程。
        * 系统资源分配给进程，同一进程的所有线程共享该进程的所有资源。
        * 处理机分配给线程，即真正在处理机上运行的是线程。
        * 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

* **11.	简述线程和协程的区别？**
    * 一个线程可以拥有多个协程，一个进程也可以拥有多个协程。
    * 创建一个线程需要操作系统的介入，而创建协程不需要，编程语言自身就能完成。
    * 线程的是同步的，调用顺序明确，而协程是异步，调用某一子程序时可以随时中断执行其它内容。
    * 协程拥有自己的寄存器上下文和栈，协程切换时会保留上一次调用时的状态。
    * 协程不是取代线程，而是抽象于线程之上，协程需要来承载运行，也就是说资源来于线程。协程通过Interceptor（执行器）来间接使用线程这个资源。

* **12. 一个进程可以创建多少个线程？**
    * 理论上，一个进程可用的虚拟空间为4G（32win下，默认是4G，其中内核与用户各占2G）。默认情况下，一个线程的栈大小为1M,所以理论上可以创建2048个线程。
    > 如果需要创建更多的线程，可修改编译器的配置更改栈大小。
    > https://www.cnblogs.com/sosi/archive/2011/03/27/1997180.html
    * 但在32位Linux环境下，内核占1G，用户占3G，一个线程默认的大小为8M，所以最多可创建约380个线程。
    * 由此可见，创建线程的数量与虚拟空间的大小和线程的大小都有关系。

* **13.	简述同步与互斥的区别？**
    * **同步**：是指散布在不同进程间的若干程序片段，它们的运行必须按照规定的某种先后次序，这种先后次序依赖于要完成特定的任务。
    > 如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
    >
    > 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的，少数情况是指可以允许多个访问者同时访问资源。
    * **互斥**：是指散布在不同进程的若干程序片段，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才能运行。
    > 如果用对资源的访问来定义的话，互斥表示某一资源只能同时允许一个访问者对其访问，具有唯一性和排他性。但互斥无法限制对资源的访问顺序。

* **14.	简述进程同步的方式？**
    * **信号量**：信号量是一个整型变量，表示系统中某种资源的数量。常使用P、V操作控制进程对资源的访问。
    > P：wait原语，如果信号量大于0，则执行-1，若等于0则进程休眠，等待大于0。
    > 
    > V：signal原语，对信号量执行+1操作，唤醒休眠的进程完成P操作。
    * **管程**：管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块。由于使用信号量机制，使得大量的同步操作分散在各个进程中，不仅给系统带来麻烦，还会因同步操作的使用不当而导致系统死锁。
    > 管程的重要特性：在同一时刻只能有一个进程使用管程。进程在无法执行的时候不能一直占用进程，否则其它进程将无法使用管程。
    * **互斥量**：采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。
    > 进程同步的原因：
    >
    > 在实现并发性的同时，也产生了异步性，使得进程间的执行顺序不可预知，因此需要实现进程同步来解决异步性的问题。

* **15.	简述线程同步的方式？**
    * **信号量**：信号量是一个整型变量，表示系统中某种资源的数量。常使用P、V操作控制进程对资源的访问。
    * **互斥量**：即mutex，得到互斥锁的线程可以执行操作，而其它线程只能等待。
    * **读写锁**：属于某种特殊的自旋锁，对应读者写者模型中，可以同时有多个读者，但只能有一个写者。
    * **事件（信号）**：用来通知线程有一些事件已发生，从而启动后续任务的开始。

* **16.	简述进程的几种状态转换？**
    * 进程主要分为就绪状态（资源已分配，等待处理机）、运行状态（正在执行）、阻塞状态（等待分配资源）。
    * **注意事项**：
        * 只有就绪态和运行态可以相互转换，其他都是单向转换。
        * 处于就绪状态的进程，可通过调度算法获得CPU，转为运行状态。运行状态的进程，在分配的CPU时间片用完后若未执行完毕，则转为就绪状态，等待下次调度。
        * 阻塞状态是由进程缺少资源由运行态转换而来，可能是进行I/O请求,缺少的资源不包括CPU，因为如果只缺少CPU，则会转为就绪态。当资源被申请到后，就会转为就绪态。

* **17.	简述创建进程的过程？**
    * 首先为进程申请一个空白的PCB：为新进程申请唯一的数字标识符，并从PCB集合中索取一个空白的PCB。
    * 为新进程分配其运行所需的资源，包括各种物理和逻辑资源。
    * 初始化进程控制块。
    * 如果进程就绪队列能够容纳新进程，便将进程插入就绪队列中。
    > **PCB的内容**：进程标识符、处理机状态、进程调度信息、进程控制信息

* **18.	简述进程间通信的方式？**
    * **无名管道**：无名管道是一种特殊的文件，只存在于内存中。
        + 无名管道只能用于具有亲缘关系的进程间通信。
        + 无名管道具有固定的读端和写端，是半双工方式，如果双方需要同时收发数据则需要两个管道。
    * **命名管道**：命名管道是FIFO文件，存在于文件系统中，可通过文件路径名找到。
        + 命名管道可以在不具有亲缘关系的进程间通信。
    * **消息队列**：消息队列是消息的链接表，存放于内核中，一个队列由一个标识符来标识。消息队列面向记录，其中的消息具有特定的格式以及特定的优先级。
        + 消息队列独立于发送与接收进程，进程终止时，消息队列及其内容不会被删除。
        + 消息队列可实现消息的随机查询，不用以先进先出的次序读取，可以按消息的类型读取。
    * **共享内存**：最快的IPC，进程直接对内存读取。
        + 分为共享数据结构和共享存储区，第一种是低级通信，第二种速度快，属于高级通信方式。
        + 对于共享存储区，进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中地址，如果某个进程向共享内存中写入数据，所做的改动将会立即影响到可以访问该共享内存的其它所有进程。
    * **信号量**：进程间共享内存与多线程间共享全局变量相似，所以在使用共享内存的同时也需要通过信号量来完成进程间同步，一般不单独使用。
    * **套接字**：与其它通信方式不同，可用于不同主机间的通信。
    > **总结**：
    >   * 无名管道：速度慢，容量有限，只有父子进程间能相互通信。
    >   * 命名管道：任何进程间都能通信，但是速度依旧很慢。
    >   * 消息队列：容量受到系统限制，且第一次读取数据时，需要考虑上一次未读完的数据，防止数据读取错误的问题。
    >   * 信号量：不能用来传递复杂信息，只能用来实现同步。
    >   * 共享内存：能够很容易控制容量，速度快，但需要保持同步，比如一个进程在写的同时，另一个进程需要注意读写的问题，相当于线程中的线程安全。

* **19.	简述为什么共享内存是最快的IPC？**
    * 首先，管道、消息队列等通信方式存在于内核中，文件的传输需要进行四次复制。第一步服务端将信息从相应的输入文件中复制到服务端的临时缓冲区，第二步从临时缓冲区中复制到管道中，第三步客户端将信息从管道复制到客户端的缓冲区中，第四步从客户端临时缓冲区将信息复制到输出文件中。
    * 共享内存只需要进行两次文件的复制，即从文件读取到共享内存中，再从共享内存中存取到输出文件中。实现方式是将同一块内存区域映射到不同进程的地址空间中，使得进程间通信不需要经过内核，但需要注意实现同步。

* **20.	简述守护进程、僵尸进程、孤儿进程的异同？**
    * **守护进程**：是一种在后台运行的特殊进程，独立于控制终端，并周期性的执行某项任务或等待处理某些发生的事件。
    * **僵尸进程**：一个进程使用fork创建子进程，当子进程退出时，父进程没有调用wait或者waitpid函数获取子进程的状态信息，那么子进程的进程描述符依旧会存在系统中，这种进程就被称为僵尸进程。
    * **孤儿进程**：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被init进程（pid = 1）所收养，并由init进程对它们完成状态收集工作。
    > 由于孤儿进程会被init进程收养，且若init进程先结束，会自动回收其子进程的资源而不是让它变成僵尸进程，所以孤儿进程没有什么危害。

* **21.	简述如何使普通进程变成守护进程？**

    **需依次进行如下操作**：
    * 屏蔽相关控制终端中断信号：防止在守护进程还未运行起来前受到控制终端的干扰退出或挂起。
    * 前台转后台运行：首先在普通进程中调用fork函数后，使父进程终止，让子进程继续执行，此时子进程为孤儿进程，并且完全是父进程的复制。
    * 脱离终端控制：登陆会话组和进程组，使用setsid()设置新会话的首进程，使其与原来的登录会话和进程组自动分离。
    * 改变工作目录：进程活动时，其工作目录所在的文件系统不能被卸下，一般需要将工作目录改变到根目录。使用chdir命令。

* **22.	简述僵尸进程的危害？**
    * 当子进程退出时，如果父进程未调用wait和waitpid函数，那么系统保留的子进程信息就不会被释放，其子进程号就会一直占用，但是系统可用的进程号是有限的，最终会导致没有可用的进程号。
    > 解决方法：
    > * 通过父进程捕获SIGCHLD信号（在一个进程终止或者停止时，将SIGCHLD信号发送给其父进程，按系统默认将忽略此信号，如果父进程希望被告知其子系统的这种状态，则应捕捉此信号），在信号处理函数调用wait()函数或者waitpid()函数处理僵尸进程。
    > * 调用fork两次，然后使子进程终止，此时孙子进程会被init进程收养，而不是变成僵尸进程，而父进程回收第一个子进程的资源。

* **23.	简述进程终止的方式？**
    * **正常终止**：
        * main函数自然返回，return
        * 调用exit函数，属于c的函数库
        * 调用_exit函数，属于系统调用
    * **异常终止**：
        * 调用abort函数，异常程序终止，同时发送SIGABRT信号给调用进程
        * 使用能够导致进程终止的信号：ctrl+C、SIGINT（SIGINT中断进程）
    > exit和_exit的异同：
    >   * 执行时，进程会无条件的停止剩下的所有操作，清除包括PCB在内的各种数据结构，并终止程序的运行。
    >   * 最大的区别在于exit函数在退出之前会检查文件打开情况，把文件缓冲区内容写回文件，也就是清理I/O缓存。


* **24.	简述处理机调度的三个层次？**
    * **高级调度**：又称作业调度，对象是作业，决定将外存中处于后备队列的某些作业调入内存中，为它们创建进程、分配必要的资源，并放入就绪队列中。
    * **中级调度**：又称内存调度，提高内存利用率和系统吞吐率，实现进程在内外存切换。
    * **低级调度**：又称进程调度，对象是进程，决定就绪队列上哪些进程获得处理机。

* **25.	简述有哪些进程调度算法？**
    * **先来先服务**：非抢占式算法，按照请求的顺序进程调度。
        + 缺点：有利于长作业不利于短作业，可能会导致短作业饿死现象。
    * **短作业优先**：非抢占式算法，按预估时间最短的顺序进行调度。
        + 缺点：有利于短作业不利于长作业， 可能会导致长作业饿死的现象。
    * **最短剩余时间优先**：抢占式算法，按照剩余运行时间的顺序进行调度。当一个作业到达时，其整个运行时间与当前进程的剩余时间比较。若新进程需要的时间更少，则挂起当前进程，运行新的进程，否则新的进程继续等待。
    * **时间片轮转**：所有的就绪进程最开始按照FCFS的顺序排队，每次调度时，将固定大小的时间片分配给队列的首个进程，执行完成后计时器发出时钟中断，将此进程放入队尾，执行下一进程。注意时间片大小必须是时钟中断周期的倍数。
        + 缺点：时间片轮转的效率与时间片大小有很大关系，如果时间片太短，会导致进程的切换过于频繁，而进程的切换需要保存进程的信息并载入新进程的信息，因此会浪费大量时间，但如果时间片过长，实时性无法得到保障，会退化为FCFS算法。
    * **优先级调度**：为每个进程分配优先级，每次在队列中选取优先级最高的进行执行。
        + 缺点：可能会导致低优先级的进程始终无法执行，可设定随时间递增而增加等待进程的优先级。
    * **多级反馈队列调度**：将时间片轮转和优先级调度相结合，把进程按优先级分为多个队列，先按优先级调度，优先级相同的再按照时间片轮转。如果该进程在当前队列执行一个时间片后未完成，则会调入下一级队列，继续等待。每个队列的时间片大小不同，从上到下依次增大。是目前较好的调度算法。
    * **高响应比优先调度**：是优先级调度的优化，使用动态优先权，使作业的优先级随时间而增加，计算优先级按照Rp=（等待时间+需要执行时间）/需要执行时间。
        + 缺点：每次调度前，都需要执行响应比计算，增加系统的开销。

* **26.	简述死锁产生的必要条件？**
    > 死锁的定义：如果一组进程中的每个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程就是死锁的。

    **四个必要条件（缺一不可）**：
    * **互斥条件**：资源不能被共享，只能由一个进程使用。
    * **请求与保持**：已经得到资源的进程可以再次申请新的资源，但没有放弃已申请到的资源，会导致一直等待该资源。
    * **不可抢占条件**：进程所获得的资源在未使用完前，不能被其它进程所剥夺，只能等待其主动释放。
    * **循环等待条件**：存在一种进程资源的循环等待链，链中的每个进程已获得的资源同时会被下一个进程请求。
    > 注意：循环等待条件是产生死锁的必要不充分条件，因为同类资源数大于1，即使产生循环等待也不会造成死锁现象。

* **27.	简述如何处理死锁问题？**
    * **预防死锁**：破坏产生死锁的必要条件一个或多个。
        1.	**打破互斥条件**：允许进程同时访问同一资源，但某些资源不能被共享，因此此方法实现困难，无实用价值。
        2.	**打破请求与保持条件**：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。
        3.	**打破不可抢占条件**：允许进程强行从占有者那里夺取某些资源。
        4.	**打破循环等待条件**：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。
    * **避免死锁**：在资源的动态分配中，以确保循环等待条件不成立，防止系统进入不安全状态。（银行家算法、资源分配图）其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。
    * **检测死锁**：允许系统产生死锁，死锁发生后，采用一定的算法解除死锁。
    * **解除死锁**：与检测死锁相配合，通常使用进程终止和资源抢占的方式。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：选择牺牲品、回滚到安全状态、饥饿（加上回滚次数限制，防止一个进程被回滚多次）。

* **28.	简述操作系统管理内存哪些功能？**
    * 操作系统负责内存空间的分配与回收。
    * 操作系统需要提供某种技术从逻辑上对内存空间进行扩充。
    * 操作系统需要提供地址转换功能，负责提供程序的逻辑地址与物理地址的转换。
    * 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰。

* **29.	简述内存的连续分配管理方式？**
    * **单一连续分配**：内存被分为系统区和用户区，系统区通常位于低地址位置，用于存放操作系统的相关数据，用户区用于存放用户进程的相关数据。
    > 注意：内存中只能存一道用户程序，独占整个用户区空间。（单用户单任务）
    * **固定分区分配**：由于多道程序系统的出现，为了在内存中能够一次性装入多道程序，将用户空间划分为若干个固定大小的分区（可相等可不相等），在每个分区中只装入一道作业，建立分区说明表，实现各个分区的分配与回收，其中表中包含分区大小、起始地址、状态。会产生内部碎片。
    * **动态分区分配**：又称可变分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态的建立分区。会产生外部碎片。
使用数据结构记录内存的使用情况：空闲分区表、空闲分区链。

* **30.	简述动态分区分配的常用算法？**
    > 基于顺序搜索的动态分区算法：
    * **首次适应算法**：空闲分区以地址递增的顺序链接，每次分配内存时，顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。是这几个中最好的动态内存分配算法。
        + 缺点：会使较大的空闲分区保留在高地址区域，但随着低地址分区会不断产生较小的分区，每次分配时查询的时间开销会增大。
    * **最佳适应算法**：空闲分区按容量递增形成分区链，每次分配内存时，顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。能使得较大的空闲分区被保留。
        + 缺点：会造成很多难以利用的外部碎片。
    * **最坏适应算法**：空闲分区按容量递减形成分区链，每次分配内存时，顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。能使得较大的空闲分区被保留。
        + 缺点：会导致较大的分区被很快使用完，而之后无法满足大进程的要求。
    * **循环首次适应**：空闲分区按地址递增的顺序链接，每次分配内存时从上次查找结束的位置开始查找空闲分区链，找到大小能满足要求的第一个空闲分区。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀。
        + 缺点：多次分配内存后，较大的分区不被保留，而之后无法满足大进程的要求。

 > 基于索引搜索的动态分区算法：
    * **快速适应算法**：又称分类搜索法，将空闲分区根据容量大小进行分类，对于每一类相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中就存在多个空闲分区链表。同时，在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型。
        + 实现过程：在搜索可分配空闲分区时，第一步根据进程的长度，从索引表中去寻找能容纳它的最小空闲区链表；第二步是从链表中取下第一块进行分配即可。
    * **伙伴系统**：Linux内核在频繁的申请释放内存时需要考虑碎片问题，使用伙伴系统来解决外部碎片问题（内部碎片使用slab解决）。
        + 实现原理：首先最开始内存为连续的一整块，且为2的n次幂，此时如果需要对需求x大小分配空间，则需要先找到2^m为比x大的第一个2的次幂，然后若此时没有该大小的区域，则会找比更大的区域拆分成两个等大小的小区域，依次类推，得到大小为2^m的区域。如果当内存释放时，有两个相同大小的区域，那么会进行合并成更大的块。

* **31.	简述对换与覆盖的区别？**
    * **对换**：是指内存中暂时不能运行的进程或者暂时不用的程序和数据换出到外存中，以便腾出足够的空间，再把已具备运行条件的进程或进程所需要的程序和数据换入到内存，可以提高内存的利用率。
    * **覆盖**：是指由于程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户空间分为一个固定区和若干个覆盖区。将活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放于外存中，在需调用前，系统将其调入覆盖区，替换覆盖区中原有的程序段。
    > **区别**：
    >   * 覆盖是在同一个进程或程序之间的，交换是在不同的进程或作业之间的。
    >   * 覆盖技术打破了程序必须全部装入内存才能运行的限制。而交换技术打破了进程进入内存就会一直运行到结束的限制。

* **32.	简述分页、分段、段页式存储管理方式（离散分配）？**
    * **分页式存储管理**：将程序的地址空间分为若干个固定大小的区域，称为页。

    同时将内存空间分为若干个物理块，页和块的大小相同，这样就可以将用户程序的某一页放入内存的某一块中，实现离散分配。Linux目前使用的是分页式存储管理方式。

    其中，用于存储的页表位于内存中，页表的起始地址保存在PCB中，存储着页号与块号的关系。

    此外还需要控制好页面长度的大小，若页面过小，会减少内存碎片，有利于内存利用率，但页表过大，占用大量内存，降低页面换进换出的效率；若页面过大，会减少页表长度，提高页面换进换出的效率，但会导致碎片变大。

    * **分段式存储管理**：分页存储是为了提高内存的利用率，而分段是为了满足程序员在编写代码时的一些逻辑需求（比如数据共享、数据保护、动态链接等）。
    
    分段存储管理方式使用段表来实现逻辑地址到物理地址的映射，段表中记录着该段在内存中的起始地址和该段空间的长度，段表可存放于内存中或者寄存器中。
    
    一个作业最多会有64k个段，每个段最多为64K长度。
    * **段页式存储管理**：采用先分段再分页的方式，两者结合，每个段对应一个页表。
    > **分段和分页的比较**：
    >  * 分页式管理方式内存的空间利用率高，不会产生外部碎片，只会产生少量的内部碎片，但不方便按照逻辑模块实现信息的共享和保护。
    >  * 分段式管理方式很方便按照逻辑模块实现信息的共享和保护，但如果段长太大，为其分配很大的连续空间会很不方便，另外，会产生外部碎片。
    >  * 页的大小相同，段的大小不同。

* **33.	简述什么是虚拟内存？**
    * 虚拟内存的定义：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其存储容量由内外存之和决定。
    * 产生的原因：如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存，所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量即可解决上述两种问题。

* **34.	简述虚拟存储器的特征？**
    * **多次性**：无需在作业运行时一次性地全部装入内存，而是允许被分成多次调入内存运行，即只需要将当前运行的那部分程序和数据将入内存即可开始运行。
    * **对换性**：无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出，即允许将暂不使用的代码和数据从内存调至外存的对换区。
    * **虚拟性**：指能从逻辑上扩充内存容量，使用户看到的内存容量，远大于实际的内存容量。

* **35.	简述虚拟存储器的局部性原理？**
    * **时间局部性**：如果执行了程序中的某条指令，不久后这条指令很有可能再次执行，如果某个数据被访问过，不久后这个数据可能再次被访问。（程序中有大量循环）
    * **空间局部性**：一旦程序访问了某个内存单元，不久后，其附近的存储单元可能会被再次访问。（因为很多数据在内存中连续存放，并且指令也是按顺序在内存中存放）

* **36.	简述虚拟存储器的实现方式？**
    * **请求分页存储管理**：在分页的基础上增加了请求调页功能和页面置换功能。
    
    允许只装入少数页面的程序（及数据），便启动运行，以后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。置换时以页面为单位。
    * **请求分段存储管理**：在分段的基础上增加了请求调页功能和页面置换功能。
    
    允许只装入少数段（而非所有的段）的用户程序和数据，即可启动运行，以后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。置换是以段为单位进行的。
    * **硬件支持**:请求分页（段）的页（段）表机制、缺页（段）中断机构、地址变换机构。

* **37.	简述页面置换算法有哪些？**
    > 在进程运行过程中，若所要访问的页面不在内存，则需把他们调入内存，但内存中无空闲的空间时，为了保证进程能够正常运行时，系统必须从内存中调出一页程序或数据送到磁盘的对换区，选择哪个页面调出需要使用页面置换算法。

    **具体算法**：
    * **最佳置换算法**：指具有理论意义的算法，策略是将当前页面中在未来最长时间内不会被访问的页置换出去，以保证最少的缺页率。
    * **先进先出置换算法**：每次淘汰最早调入的页面，把进程以调入内存的先后顺序链接成队列，设置替换指针，指向最早的页面。
    * **最近最久未使用置换算法（LRU）**：每次淘汰的页面是最近最久未使用的页面。在赋予每个页面对应的页表项中，使用访问字段记录上一次该页面自上次被访问以来经历的时间t，然后当需要淘汰页面时，选择t值最大的进行淘汰。底层可使用hashmap或双向链表实现。
    * **最少使用置换算法**：设置寄存器记录页面被访问的次数，每次置换当前访问次数最少的页面。
    * **时钟置换算法**：像时钟一样扫描缓冲区，又名clock算法，是一种性能和开销均衡的算法。方法：为每个页面设置一个访问位，其中1表示最近访问过，0表示最近未访问过，再将内存中的所有页面链接成一个循环链表，进行淘汰时会循环遍历，若当前页面为0，则取出该页换出，否则，则置为0，不换出；当出现第一轮没有可选择的页面时，由于将所有页面都置为0，所以第二轮必能找到，因此该算法每次最多会进行两轮扫描。
    * **改进的时钟置换算法**：简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I/O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。

    > 因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型时钟置换算法的思想。修改位=0，表示页面没有被修改过;修改位=1，表示页面被修改过。
    > 
    > 若用(访问位，修改位)的形式表述，则第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)
    > 
    > 因此每次执行改进的CLOCK算法只需要至多轮询四次。

* **38.	简述外部碎片和内部碎片的区别？**
    * **内部碎片**：指已经分配出去的内存空间大于请求所需的内存空间。
    * **外部碎片**：指没有被分配出去，但是由于大小太小而无法分配给新进程的内存空间。
    > 如何解决碎片问题：
    >   * Linux内核在频繁的申请释放内存时需要考虑碎片问题，使用伙伴系统来解决外部碎片问题（内部碎片使用slab解决）。

* **39.	简述抖动产生的原因？**
    * 同时在系统中运行的进程过多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，导致每个进程运行时，频繁的出现缺页，必须请求系统将所缺的页调入内存。这会使得在系统中排队等待的页面调进/调出的进程数目增加，造成每个进程的大部分时间都用于页面的换进/换出，几乎不能完成有效的工作，此时称进程处于抖动状态。

* **40.	简述逻辑地址与物理地址的区别？**
    * **逻辑地址**：指由程序产生的与段相关的偏移地址部分，即相对于进程在内存中的起始地址而言的地址。
    * **物理地址**：指出现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果地址，即在内存中的地址。
    * 相对地址又称逻辑地址，绝对地址又称物理地址。

* **41.	内存交换时，被换出的进程存在哪？**
    * 保存在磁盘中，也就是外存中，一般会将磁盘区域分为文件区和对换区，文件区用于存放文件，主要追求存储空间的利用率，因此采用离散分配的方式；对换区只占磁盘的小部分，主要追求换入换出的速度，采用连续分配方式。

* **42.	简述ASCII、Unicode和UTF-8的区别？**
    * **ASCII**：ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号但无法表示汉字等语言信息。
    * **Unicode**：由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，Unicode就应运而生，Unicode将语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果编译的文本是全英文，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上十分不划算。
    * **UTF-8**：为了解决上述问题，又出现了把Unicode编码转化为“可变长编码”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。

    > 三者联系：
    >   * 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。
    >   * 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。

* **43.	简述操作系统几种典型的锁？**
    * **读写锁**：多个读者可以同时读，写者必须互斥，写者必须优先于读者。
    * **互斥锁**：一次只能有一个线程拥有互斥锁，其它线程只能等待互斥锁的释放。

    互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再被唤醒，而操作系统负责线程的调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要将锁交给操作系统管理，所以互斥锁在加锁操作时会涉及上下文的切换。 创建互斥锁：pthread_mutex_t mutex
    * **条件变量**：互斥锁明显的缺点就是只有两种状态：锁定与非锁定。
    
    条件变量常与互斥锁一起使用，一旦一个线程对互斥锁进行了加锁，那么其它线程就无法进入临界区，也就没有办法改变所等待的条件，而条件变量可以解锁然后等待条件发生变化。一旦其它的线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正在被此条件变量阻塞的线程。
    * **自旋锁**：如果进/线程无法取得锁，进/线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时间占有锁，那么自旋锁就是在浪费CPU做无用功，但是自旋锁一般用于加锁时间很短的场景，效率会很高。
    * **乐观锁**：总是假设最好的情况，每次去拿数据时都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。
    
    **版本号机制**：在数据表中增加version字段，表示数据被修改的次数，每次更新时会使version+1,当提交更新时需判断当前version跟之前是否一致，如果不一致，会重试更新操作，直到完成更新为止。
    * **悲观锁**：总是假设最坏的情况，每次去拿数据时都认为别人会修改，所以每次在拿数据时都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。关系型数据库中应用比如行锁、表锁、读锁、写锁等。

* **44.	简述大端小端字节序？**
    * **大端**：高尾端，高位字节在前，低位字节在后。在TCP/IP使用的网络字节序就是大端字节序。
    * **小端**：低尾端，低位字节在前，高位字节在后。在X86位计算机中，使用的是小端字节序。

* **45.	在单核机器上写多线程程序，需要考虑加锁问题吗？**
    * 在单核机器上写多线程程序，仍然需要线程锁。
    * 因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。

* **46.	游戏服务器中为每个用户开线程还是进程？**
    * 服务器为每个用户创建的是进程。
    * 原因是因为同一进程间的线程会相互影响，一个线程死掉会影响其它线程，从而导致进程崩溃。因此为了保证不用用户间不会相互影响，应该为每个用户开辟进程。

* **47.	简述五种网络I/O模型？**
    * 网络IO的本质就是socket流的读取，通常一次IO读取会涉及两个阶段与两个对象，其中两个对象为：用户进程（线程）Process（Thread）、内核对象（kernel）,两个阶段为：等待流数据准备阶段、从内核向进程复制数据阶段。
    * 对于socket而言，第一步通常等待网络上的数据分组到达，然后被复制到内核的某个缓冲区，第二步数据从内核的缓冲区复制到应用进程的缓冲区。

    * **五种网络IO模型**：
        + **阻塞IO**：在linux中，默认所有的IO都是阻塞IO，特点是读取数据时两个阶段都是阻塞的。当用户进程调用recvfrom这个系统调用时，kernel就开始等待数据到来，而进程这边会处于阻塞状态。当kernel将数据准备好后，就会将数据拷贝到用户进程的缓冲区，然后kernel返回结果，用户进程才会解除block状态，重新运行起来。
        + **非阻塞IO**：与阻塞IO不同，当用户进程发出recvfrom调用时，如果kernel中数据还没有准备好，那么并不会block用户进程，而是会返回error错误。相对于用户进程而言，每次发送读取操作后，并不需要等待，而是会立刻返回结果，当收到error时，就知道数据未准备完毕，然后继续发送读取操作，直到可以直接读取数据到缓冲区为止。虽然在执行read请求操作时，用户进程并未阻塞，但是当recvfrom将数据从内核拷贝时，用户进程处于阻塞状态。
        + **多路复用IO**：又称事件驱动IO，进程使用IO多路复用在两个阶段都是阻塞的状态，进程使用select函数，其中select函数有一个参数是文件描述符集合，对这些文件描述符进行监听，当文件描述符就绪时，会返回readable信号，然后用户进程调用recvfrom进行读取数据，由于可同时监听多个IO,效率比阻塞IO高。
        > 主要通过select、poll、epoll三种方式实现。
        + **信号驱动IO**：首先应用进程通过sigaction系统调用安装一个信号处理函数（在内核位置），该系统调用立即返回，进程继续工作（未被阻塞）。当数据准备就绪时，kernel就会为该进程产生一个SIGIO信号，随后用户进程就可以使用recvfrom调用去读取数据到内存，并返回成功指示。
        + **异步IO**：真正意义上的非阻塞IO，当用户进程发出aio_read操作之后，就立刻可以去做其它的事。另一方面，当kernel的角度，当kernel收到read信号后，会立刻返回结果，所以不会对用户进程block。之后，kernel会等待数据准备完毕，然后将数据拷贝到内存中，完成之后，kernel会给用户进程发送signal信号，表示数据已经read操作完毕。整个过程无阻塞状态的发生。
    > **总结**：
    >   * 阻塞IO、多路复用IO是两个阶段都处于阻塞状态，非阻塞IO、信号驱动IO是在第二阶段从kernel读取数据时处于阻塞状态，异步IO整个过程都未处于阻塞状态。
    >   * 按照阻塞程度排序：阻塞IO > 非阻塞IO > 多路复用IO > 信号驱动IO > 异步IO 并且效率由低到高。
    >   * IO同步与异步的区别在于将数据从内核复制到进程内存过程中，进程是否阻塞。
    >   * IO阻塞与非阻塞的区别在于调进程系统调用时，结果是否会立刻返回。

* **48.	简述什么是文件描述符？**
    * 文件描述符是一个用于表述指向文件的引用的抽象化概念，形式上是一个非负整数，实际是以一个索引值，指向内核为每个进程所维护的该进程打开文件的记录表。
    * 当程序打开一个现有文件或者创建一个新文件，内核向进程返回一个文件描述符。

* **49.	简述IO多路复用中poll、epoll、select的区别？**
    * **select**：进程调用select后会被阻塞，将需要监听的文件描述符放入fd_set,并将fd_set复制到内核空间，内核空间会对fd_set进行轮询遍历，若无mark值，则会暂时挂起等待超时时间之后继续轮询，直到有数据准备就绪。最后将fd_set复制回用户进程，进行读/写操作。
    > **缺点**：
    > 1. select能监控的fd数量有上限，32位系统一般为1024，64位系统为2048，这个上限可以通过修改参数提高，但是相应的会损失性能。
    > 2. 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。
    > 3. 需要维护一个用来存放大量fd的数据结构，用户空间需要维护一个fd_set，fd_set的每一位都表示一个文件描述符，开始时会将其发给内核，这会使得用户空间和内核空间在传递该结构时复制开销大。
    * **poll**：poll和select基本是一样的，但是它对fd集合做了优化，使用链表存储，解决了连接数上限的问题。
    > **缺点**：
    > 1. 同select一样需要维护数据结构，复制时开销较大。
    > 2. 具有水平触发的特点，如果报告了fd后未被处理，下次poll会再次报告该fd。
    * **epoll**：同select、poll不同，复杂度O（1），通过三个函数实现流程：
        1.	**epoll_create**：创建一个epoll文件描述符集合，同时底层创建一个红黑树和就绪链表，红黑树存储所监控的文件描述符的节点数据，就绪链表存储就绪的文件描述符的节点数据。
        2.	**epoll_ctl**：用于添加新的描述符，首先判断红黑树中是否存在，如果不存在，插入数据，并告知内核注册回调函数（当文件描述就绪时通过网卡驱动触发），数据就绪后将事件添加到就绪队列中。
        3.	**epoll_wait**：检查链表，并将数据拷贝到用户空间（两者维护的是片共享内存），最后清空链表。其中epoll的工作方式分为LT、ET。
    > 注意：epoll是线程安全的，但是当一个线程调用epollwait，而另一个线程用epollctl向同一个epoll_fd添加一个监测fd后，epollwait有可能被改fd的读/写事件唤醒。

* **50.	是不是任何时候epoll的效率都最高？**
    * 不是，在连接数比较少的时候，使用epoll可能比使用select、poll的性能更低，因为epoll需要执行一个额外的回调函数；所以epoll适用于高连接数并且活跃连接数不高的场景。

* **51.	简述epoll的水平触发、边缘触发？**
    * **水平触发(LT)** ：若就绪的事件一次没有处理完要做的事件，就会一直去处理。即就会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行处理。 
    * **边缘触发(ET)** ：就绪的事件只能处理一次，若没有处理完那么下次不会再通知应用进程读取数据，降低了同一事件被重复触发的次数。
    * ET模式的效率比LT模式的效率要高。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码要求比较高。 
    > 注意：ET模式只支持非阻塞的读写：为了保证数据的完整性。

* **52.	简述软链接和硬链接的区别？**
    * **软链接**：可理解为快捷方式，只是维持了从软链接到源文件的指向关系，软链接文件的大小和创建时间和源文件不同。
    * **硬链接**：硬链接文件和源文件的大小和创建时间一样。硬链接文件的内容和源文件的内容一模一样，相当于copy了一份。
    * 创建软链接的命令：ln -s 源文件名称 目标文件名称
    * 创建硬链接的命令：ln 源文件名称 目标文件名称
    * 软连接不会增加引用计数，而硬链接会增加引用计数。

* **53.	简述fork和vfork的区别？**
    * **fork**：一个现有进程可以调用fork创建子进程。
    
    fork被调用一次但返回两次，区别是子进程中返回0，而父进程返回子进程PID。
    
    子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本，而不是共享存储空间，另外父子进程没有固定的执行顺序，靠进程调度策略。
    * **vfork**：一个现有进程可以调用vfork创建子进程。
    
    vfork创建的子进程与父进程共享数据段，且保证子进程先于父进程执行，在子进程调用exit或exec后，再调用父进程。但是若子进程执行的某一步需要父进程的动作，就会导致死锁现象。

* **54.	简述常见的磁盘调度算法？**
    * **先来先服务**：按照磁盘请求的顺序进行调度。优点是公平和简单，缺点是因为未对寻道做任何优化，使平均值寻道时间可能较长。
    * **最短寻道时间优先**：优先调度与当前磁头所在磁道距离最近的磁道。
    
    虽然平均寻道时间比较低，但是不公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，出现饥饿现象。
    * **电梯扫描算法**：电梯总是保持一个方向运行，直到该方向没有请求，然后改变运行方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了饥饿现象。

* **55.	简述调度算法中的公平调度算法（补充）？**
    * 目前Linux支持三种进程调度策略，分别是SCHED_FIFO 、 SCHED_RR和SCHED_NORMAL；而Linux支持两种类型的进程，实时进程和普通进程。实时进程可以采用SCHED_FIFO 和SCHED_RR调度策略；普通进程则采用SCHED_NORMAL调度策略。从Linux2.6.23内核版本开始普通进程（采用调度策略SCHED_NORMAL的进程）采用了绝对公平调度算法，不再跟踪进程的睡眠时间，也不区分是否为交互式进程，它将所有的进程都统一对待，这就是完全公平的含义。
    * CFS完全公平调度算法现在是linux内核的默认调度算法。
    * **CFS实现原理**：首先给cfs__rq（run queue）中的每个进程都设置一个虚拟时钟vruntime，如果一个进程执行任务，随着执行时间的增长，其虚拟时钟值会不断增大，未执行的进行不会被改变。另外，调度器将会选择最小的vruntime那个进程来执行。这就是所谓的“完全公平”。不同优先级的进程其vruntime增长速度不同，优先级高的进程vruntime增长得慢，所以它可能得到更多的运行机会。
    * **底层实现**：CFS算法的底层使用红黑树实现，将可运行的任务插入树中，每次选择数中vruntime最小的进程运行。

* **56.	简述进程切换哪些内容？**
    * 切换页目录以使用新的地址空间。
    * 切换内核栈和硬件上下文。

* **57.	如何使进程在后台运行？**
    * **nohup**：用途就是让提交的命令忽略 hangup 信号。nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上"&"来将命令同时放入后台运行，也可用">filename 2>&1"来更改缺省的重定向文件名。
    * **setsid**：setsid()调用成功后，返回新的会话的ID，调用setsid函数的进程成为新的会话的领头进程，并与其父进程的会话组和进程组脱离。由于会话对控制终端的独占性，进程同时与控制终端脱离。

* **58.	进程上下文切换时PCB保存的内容有哪些？**
    * **标识符**：唯一标识一个进程。
    * **状态**：记录进程的状态，如阻塞、就绪、运行等状态。
    * **优先级**：记录进程的优先级，可以根据优先级对进程进行调度。
    * **程序计数器PC**：指向进程中下一条将要执行的指令。
    * **上下文数据**：进程运行时，CPU中寄存器的内容。
    * **I/O状态信息**： 显示的I/O请求，分配给进程的I/O设备、被进程使用的文件列表。

* **59.	进程线程切换的性能开销？**
    * 线程上下文切换的虚拟内存空间不变，而进程切换会改变。上下文切换都是通过内核完成，最显著的开销是将寄存器中的内容切换出。
    * 进程上下文的切换还会导致处理器的缓存机制失效，因为一旦切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。并且会刷新页表缓冲TLB，导致之后一段时间内存的访问会十分低效。而在线程切换时不会发生。

* **60.	操作系统现有4G物理内存，已有进程A占用2.5G内存，问此时若Afork子进程，会不会成功？为什么？**
    * 会成功。
    * 使用了写时拷贝技术（copy on write），fork之后父子进程使用的是相同的物理空间，子进程的代码段、数据段、堆栈都是指向父进程的物理空间。也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。

61.	简述gdb调试常用命令？
    * https://blog.csdn.net/niyaozuozuihao/article/details/91802994
    * 编译c++程序：g++ -g main.cpp -o main.exe 之后执行 ./main.exe即可运行
    * 启动gdb调试：gdb main.exe  若使用-q参数 则不打印版本信息，页面更加简洁
    * 查看源码内容：list  默认显示程序前十行，按回车继续显示
    * 运行程序：run  运行程序直到结束或遇到断点等待下一个命令
    * 设置断点：break num  在num行设置断点
    
    > 使用info breakpoints可显示断点信息，包括：Num（断点编号）、What（位置）、Address（内存地址）、Disp（断点执行一次后是否有效，keep,dis）、Enb（当前断点是否有效，y,n）
    * 单步执行：使用continue、step、next命令
    * 查看变量：使用print、whatis命令
    * 退出gdb：quit命令

    **相关命令展开介绍**：
    * **查看源码**：
        * list显示行信息 默认前十行
        * list+行号 显示当前文件以该行号为中心的前后十行代码
        * list+函数名 显示函数名所在函数的源代码
    * **运行命令**：
        * run 运行程序直到结束或遇到断点等待下一个命令
        * continue 继续执行，到下一断点位置或结束
        * next 单步执行调试，但遇到函数时，直接执行而不进入
        * step 同单步调试 但是会进入函数内部
        * until 当厌倦了在循环体内一直单步，可执行until直接运行到退出循环体
        * until+行号 运行至某行
        * quit 退出gdb
    * **设置断点**：
        * break+n 在第n行设置断点
        * break+函数名 在函数入口位置设置断点
        * delete+n 删除第n个断点
        * disable/enable+n 暂停/开启第n个断点
        * clear+n 清除第n行的断点
        * info breakpoints 显示断点具体信息
        * delete breakpoints 清除所有断点
    * **打印表达式**：
        * print a 显示整数/字符串a的值   print a++ 将a的值+1，并显示a的值 
        * display+表达式 将在每次单步进行指令后，紧接着输出被设置的表达式及值。
        * watch+表达式 设置一个监视点，当监视的表达式值改变时，并终止程序
        * whatis 查询变量或函数
    * **查看运行信息**：
        * where/pt 当前运行的堆栈列表
        * bt backtrace 显示当前调用堆栈
        * up/down 改变堆栈显示的深度
        * info program 查看程序是否在运行，进程号，被暂停的原因

* **62.	简述C++代码执行的全过程？**
    * **预编译**：主要是处理代码中#开头的预编译指令。
        1.	删除所有的#define,展开所有的宏定义。
        2.	处理所有的条件预编译指令，如#if，#endif，#ifdef等。
        3.	处理#include头文件，将文件内容替换到它的位置，此过程是递归执行的。
        4.	删除所有的注释内容，//和*/。
        5.	保留所有的#pragma编译器指令，编译器需要使用，其中#pragma once是防止头文件被重复引用。
        6.	添加行号和文件标识，便于编译时编译器产生调试用的行号信息和编译时产生编译错误或警告时能够显示行号。
    * **编译**：将预编译之后生成的文件，进行词法、语法、语义分析及优化后，生成相应的汇编文件代码。
        1.	词法分析：将源程序输入到扫描机中，将其中的字符序列分割成一系列的记号。
        2.	语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树
        3.	语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
        4.	优化：源代码级别的优化过程。
        5.	目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。
        6.	目标代码优化：对目标代码进行优化：寻找合适的寻址方式、使用位预算代替乘法运算、删除多余的指令等。
    * **汇编**：将汇编代码转变成机器可以执行的指令(二进制机器码文件)。 
    * **链接**：将不同源文件产生的目标文件进行链接，从而形成一个可执行的文件。

    > **链接的分类**：
    > 
    >   **静态链接**：函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
    >   + 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本。
    >   + 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
    >   **动态链接**：动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
    >   + 共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；
    >   + 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
    >   + 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

* **63.	积累Linux面试常用命令：**
    * 查看进程状态信息：

        `ps -l 列出与本次登录有关的所有进程`

        `ps -aux  查看内存中的进程信息`

        `ps -aux | grep pid  查询具体pid的进程信息 top 查看内存中进程的动态信息 `

    * 如何杀死一个进程：

        `kill -9 pid  杀死具体pid的进程`

    * 查看内存的使用情况：

        `+ free、top  都会显示内存占比情况`

    * 如何使进程在前后台进程切换：

        `在前台运行的进程使用ctrl+z切换为后台挂起，接着使用（bg 作业号）转为运行`

        `后台转为前台：fg 作业号 `

        `作业号pid可以使用%n替换，%n是使用jobs查看的后台正在执行的进程序号`

    * 如何设置栈大小：

        `ulimit -a  显示当前栈大小`

        `ulimit -s 32768  将当前栈大小设置为32MB`

    * 如何查看IO多路复用时使用select的最大连接数：

        `cat /proc/sys/fs/file-max`

    * 如何对一个文件内容进行统计（字符数、字数、字节数）：

        `wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数`

    * 如何使用grep进行文本查找：

        ``grep -rn `xubenqi` ``

        `查找非某字符串 grep -rn [^xubenqi]`