# 计算机网络面试知识点汇总

> 计算机网络面试题目整理，后续遇到好的问题会不断更新。
>
> 如有错误须更正，请联系1726977432@qq.com

---

![网络结构图](../../_media/网络结构.jpg ':size=30%')

## 概述
---

* **1. OSI七层网络模型划分及作用？**
    * **物理层**：利用传输介质为链路层提供物理连接，实现比特流的透明传输。
    * **链路层**：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。
    * **网络层**：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。控制传输层与数据链路层之间的信息转发，建立、维持和终止网络的连接。
    * **传输层**：定义一些传输数据的协议和端口。传输协议的同时进行流量控制，或是根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题。
    * **会话层**：负责在网络中的两节点中建立、维持和终止通信。
    * **表示层**：确保一个系统的应用层发送的消息可以被另一个系统的应用层读取，负责编码转换，数据解析，管理数据的解密和加密。
    * **应用层**：各种应用程序协议，为应用程序提供给服务。

* **2. 四层网络模型与五层网络模型是如何划分的？**
    * **四层**：网络接口层、网络层、传输层、应用层
    * **五层**：物理层、数据链路层、网络层、传输层、应用层

* **3. 为什么需要对网络进行层级划分？**
    * 把网络操作分成复杂性较低的单元，结构清晰，易于实现和维护。
    * 每一层只需要完成特定的功能，并对其上下层提供相应的接口即可，如果需要修改其功能，只需要对某一部分内容进行修改。

* **4. 为什么会有不同种类的网络模型分层方式？**
    * 七层协议结构的概念清楚、理论完整，但既复杂又不实用。
    * 五层协议是为了介绍网络原理而设计的，四层协议才是真正的实际应用。

* **5. 每层网络模型都包含哪些协议？**
    * **数据链路层**:ARP(IP转MAC)、RARP（MAC转IP）
    * **网络层**:ICMP(网络控制报文协议)、IP(互联网协议)、OSPF(开放最短路径优先协议)
    * **传输层**:TCP(传输控制协议)、UDP(用户数据报协议)
    * **会话层**:SSL(安全套接字协议)、TLS(传输层安全协议)
    * **应用层**:HTTP(超文本传输协议)、FTP(文件传输协议)、SMTP(简单邮件传输协议)、DHCP(动态主机配置协议)、TFTP(简单文件传输协议)、NTP(网络时间协议)
    > 注：ARP也可以说是网络层协议，属于一个“非正式”层，介于两者之间。

* **6. 每层网络模型传输数据的单位是什么？**
    * **物理层**：比特流       
    * **链路层**：帧
    * **网络层**：包
    * **传输层**：报文段

## 链路层
---

* **7.	简述ARP（地址解析协议）的实现过程？**
    * 首先，每个主机都有一个ARP列表，用来缓存IP地址与MAC地址之间的映射关系。
    * 当源主机发送数据时，首先会检查其ARP缓存列表中是否存在目的IP地址对应主机的MAC地址，如果有，则直接可以对其发送数据。
    * 否则，会以广播的形式向本网络的所有主机发送ARP数据包，其内容包括：源主机IP地址、源主机MAC地址、目的主机IP地址。
    * 当本网络的所有主机接收到该数据包时，首先会检查自己的IP地址是否是需要的目的IP地址。
        + 如果没有，则直接忽略。
        + 如果存在，则先将数据包中的源主机IP、源主机MAC地址写入自己的ARP列表中，可被覆盖，其次将自己的MAC地址写入ARP响应包中，以单播的形式发送。
    * 当源主机接收到响应后，会将目的地址的信息写入ARP缓存列表，然后发送数据。
    * 上述方法适用于主机位于同一子网下，否则需要通过**网关转发**实现。

* **8. 简述RARP（逆向地址解析协议）的实现过程？**
    * **多应用于无盘机**：一个网络中的所有主机都不安装硬盘，通过网络服务来启动，这些主机都不保存自己的IP地址，这样的网络叫做无盘网络，这些机器叫做无盘机，无盘网络主要为方便管理维护无盘机而存在。
    * 在网络中配置一台RARP服务器。当RARP服务器启动后，就会将MAC地址封装成一个RARP数据包，然后广播到网络上去，当服务器接收到请求包后，就会查找对应MAC地址的IP地址，装入响应报文中发回请求者。
    > 现在DHCP中已经包含了RARP的功能。

## 网络层
---

* **9.	简述ICMP协议及其作用？**
    * ICMP协议是网络控制报文协议，最常用的命令是ping，用于检测网络可用性。
    * 由于IP协议是不可靠协议，不保证数据被送到，那么保证数据送达的工作将由其它模块完成，其中最主要的就是ICMP协议。
    * 当传送IP数据包发生错误时（主机不可达、路由不可达），ICMP协议会将错误信息封包，再传送回主机，给主机一个处理错误的机会，因此，ICMP具有确认IP包是否成功送达目标地址、报告发送过程IP 包被废弃的原因和改善网络设置等功能。
    * **ICMP协议命令**：
        + netstat(显示网络相关信息，比如网络连接、路由表、接口状态等)
        + traceroute(用来侦测主机到目的主机间所经路由情况的信息)

* **10.	一个IP可以对应多个域名吗？反之？**
    * 可以，网络中的主机通过IP进行标识，每台主机可绑定多个域名，但只有一个IP。
    * 同样一个域名可以对应多个IP，当进行DNS解析服务时会将所有IP返回，大多数软件会取第一个IP,这同样是DNS负载均衡的问题原理。

* **11.	一个IP配置多个域名，靠什么识别？**
    * Http请求中的host域（http1.1及以后）
    * 端口号识别，不同端口号指向不同的网站代理

* **12.	两台主机相连后ping不通，可能是哪些原因导致？**
    * 网络时延过高
    * 第三方软件拦截
    * 网卡驱动是否正确安装
    * 局域网设置问题，IP地址可能设置错误
    * 有些设置中防火墙会对ICMP报文进行过滤

* **13.	交换机与路由器的区别？**
    * 交换机位于数据链路层，能识别MAC地址，根据MAC地址转发链路层数据帧。
    * 路由器位于网络层，能识别IP地址并根据IP转发分组，维护路由表，根据路由表选择最佳路径。

* **14.	简述路由器的分组转发流程？**
    * 首先从IP数据包中提取出目的主机的IP地址，找到其所在的网络。
    * 判断目的IP地址所处的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则，执行下一步。
    * 检查路由表中是否有目的IP地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行下一步。
    * 逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行下一步。
    * 若路由表中设置有默认路由，则按照默认路由表转发到下一跳路由器中，否则执行下一步。
    * 无法找到合适路由，向源主机报错。

* **15.	简述IP地址如何分类？**
    * IP地址共32位，4个字节，表示为X.X.X.X，由网络号与主机号组成。
    * A类：8位网络号+24位主机号   
        + 开始：0
        + 默认子网掩码：255.0.0.0
    * B类：16位网络号+16位主机号  
        + 开始：10       
        + 默认子网掩码：255.255.0.0
    * C类：24位网络号+8位主机号   
        + 开始：110      
        + 默认子网掩码：255.255.255.0
    * D类：多播地址          
        + 开始：1110
    * E类：保留地址                
        + 开始：1111

* **16.	简述有哪些特殊的IP地址？**
    * **私有地址**：A类：10.0.0.0～10.255.255.255   B类：172.16.0.0～172.31.255.255    C类：192.168.0.0～192.168.255.255
    * **回送地址**：127.0.0.1  就是本机地址，等效于localost或本机IP
    * **广播地址**：255.255.255.255   指本网段的所有主机，但不能被路由转发
    * **组播地址**：224.0.0.1  组播地址，从224.0.0.0到239.255.255.255都是这样的地址。224.0.0.1特指所有主机，224.0.0.2特指所有路由器。
    * 0.0.0.0 表示集合：所有不清楚的主机和目的地址

17.	简述子网掩码的作用
    * 子网掩码可以分离出IP地址中的网络部分和主机部分
    * 子网掩码可用于将大的IP网络划分为若干个小的子网络

* **18.	IPv4和IPv6的有哪些区别？**
    * **地址长度不同**：IPv4为4字节，IPv6为16字节，因此寻址范围不同。
    * IPv6具有更安全性：在使用IPv6网络中，用户可以对网络层的数据进行加密并对IP报文进行校验，极大的增加了网络的安全性。
    * IPv6使用的固定报头，IPv4会携带冗长的数据，因此提高了网络数据转发的效率。
    * IPv6的路由表更小，聚合能力更强，数据转发路径更短，提高了转发效率。
    * 支持无状态自动地址配置：IPv6无需DNS服务器也可完成地址的配置，路由广播地址前缀，各主机根据自己MAC地址和收到的地址前缀生成可聚合全球单播地址。

* **19.	简述IP的首部报文结构组成？**
    * 第一行：4位版本号、4位首部长度、8位服务类型（TOS）、16位总长度，共4B
    * 第二行：16位标识符、3位标志、13位片偏移
    * 第三行：8位生存周期（TTL,每经过路由器TTL-1）、8位协议、16位首部校验和
    * 接下来每行：32位源IP地址、32位目的IP地址、选项（如果有）、数据

* **20.	网络层分片的原因及具体实现？**
    * **原因**：MTU（最大传输单元）：数据链路层的限制，所以需要IP分片。
    * **实现**：发送方会在网络层将要发送的数据分成多个数据包分批发送，而接收方则将数据按照顺序再重新组织，等收到一个完整的数据报之后，再提交给传输层。
    * IP头部有三位标志字段，用来标识是否为分片包。其中第一位无用（保留位），第二位DF=0:允许分片，DF=1:不允许，第三位MF=0:最后一片，MF=1:后面还有分片；另外，13位offset段偏移量用于IP重组时数据排序。

* **21.	简述NAT协议的作用及实现方式？**
    * NAT即网络地址转换协议，可将内部私有网络地址翻译成公有网络IP地址，该技术不仅能解决IP地址不足的问题，还能隐藏和保护网络内部主机，从而避免来自外部网络的攻击。
    * **NAT的主要实现方式有三种**：
        + **静态转换**：内部私有IP地址与公有IP地址是一对一的关系，并且不会发生变化。但是当某一公有IP被占用时，内部主机将无法访问Internet。
        + **动态转换**：当私有IP地址被授权访问网络时会被随机转换成合法的公有IP地址。
        + **端口多路复用**：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部公有IP地址，从而最大限度的节约IP地址资源。同时，又可以隐藏内部网络中的主机，避免外部攻击。

* **22.	MAC地址与IP地址为什么必须同时存在？**
    * 只存在IP地址：由于分配IP使用的是DHCP协议，不同主机可能会拥有相同IP，因此IP不是主机的唯一标识。
    * 并且在实现信息传递功能时，IP地址记录的是最终地址，而MAC地址则是记录下一跳地址，每跳过一次路由器都会改变。
    * 只存在MAC地址：MAC地址虽然是主机的唯一标识，但是它并不能表示所在的位置，如果建立MAC路由表，则整个路由表会异常庞大，查询会慢很多，而IP可以标识位置信息。

## 传输层
---

* **23.	分别简述什么是TCP、UDP，二者有哪些区别？**
    * TCP为传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。
    * UDP为用户数据报协议，是一种无连接的传输层协议，提供不可靠的信息传送服务。
    * **区别**：
        + TCP基于连接、稳定可靠、速度慢，而UDP无连接、速度快、不可靠、不稳定
        + TCP只能支持点对点，而UDP支持一对多、多对多、多对一的交互通信
        + TCP面向字节流、UDP面向报文
        + TCP首部20个字节，而UDP占8个字节
        + TCP开销大，而UDP灵活开销小

* **24.	为什么说TCP面向字节流而UDP面向报文？**
    * UDP对于应用程序传下来的报文，既不合并、也不拆分，保留这些报文的边界，在添加首部后直接交付给IP层。
    * TCP对于应用程序传下来的报文，视为无结构的字节流（无边界约束，可拆分/合并）。

* **25.	简述与TCP、UDP相关的协议及端口号？**
    * **TCP**:
        + FTP:文件传输协议                   端口号：21
        + HTTP:超文本传输协议                端口号：80
        + SSH: 安全外壳协议                  端口号：22
        + SMTP:简单邮件传送协议              端口号：25
        + TeInet:用于远程登录                端口号：23
        + POP3:与SMTP对应，用于接收邮件     端口号：110
    * **UDP**：
        + DNS:域名解析协议                   端口号：53
        + DHCP:动态主机配置协议              端口号：68
        + SNMP:简单网络管理协议              端口号：161

* **26.	简述TCP的报文格式？**
    * 第一行：16位源端口号、16位目的端口号
    * 第二、三行：32位序列号、32位确认号
    * 第四行：4位偏移量、保留位（6位）、URG(紧急指针有效性标志)、ACK(确认序号标志)、PSH(push标志，若为真，则表示优先对该数据处理)、RST(重置连接标志)、SYN(同步序号)、FIN(finish标志,用于释放连接，表示数据发送完毕)、16位窗口大小(滑动窗口大小)
    * 第五行：16位校验和、16位紧急指针
    * 可选项

* **27.	简述UDP的报文格式？**
    * 第一行：16位源端口号、16位目的端口号
    * 第二行：16位包长度（记录UDP首部和数据长度之和）、16位校验和
    * 数据部分

* **28.	简述TCP三次握手的过程？**
    * 最初C/S双方都处于CLOSED状态。
    * 首先客户端会发送请求连接报文，首部标志位SYN=1，并且设置序列号seq=x，此时客户端进入SYN-SENT状态，并且SYN报文未携带数据。
    * 当服务端接收到SYN报文后，会发送ACK确认报文，此时首部标志位ACK=1、SYN=1,确认号ack=x+1,此时再设定seq=y,此时服务端进入SYN-RCVD状态，且不携带数据。
    * 当客户端收到ACK报文后，会发送ACK确认报文，设置ACK=1，seq=x+1,ack=y+1，并进入到ESTABLISHED状态，此时报文可携带数据。
    * 最后，当服务端收到报文后也进入ESTABLISHED状态。

* **29.	TCP两次握手可以吗？**
    * 不可以，如果连接过程中，客户端的SYN报文迟迟没有到达服务端，那么此时客户端超时后，会重新发送一次连接，那么当请求到达服务端时，会正常建立连接。当连接后，如果第一次的SYN报文到达服务端，服务端会认为这是一个新连接，会给客户端发送ACK报文，虽然客户端会进行丢弃，但服务端会一直维持着这个资源，造成资源的浪费。
    * 两次握手的问题在于服务端不知道SYN报文的有效性，所以三次握手时，服务端会等待客户端的第三次握手报文，如果超时未到，就会释放相关资源。

* **30.	简述TCP四次挥手的过程？**
    * 最初，当C/S进行数据传输时，都处于ESTABLISHED状态。
    * 数据传输结束后，客户端会发出连接释放报文段，且停止发送数据，首部标志位FIN=1，序列号seq=x,并进入FIN-WAIT-1状态。
    * 服务端收到FIN报文后，说明知道客户端想要断开连接，返回ACK报文，首部标志位ACK=1,seq=y,ack=x+1,并进入CLOSED-WAIT状态，而客户端收到ACK报文后会进入FIN-WAIT-2状态，等待服务端的数据传输结束。
    * 当服务端数据传输完毕后，服务端发送FIN报文，首部标志位FIN=1，ACK=1，seq=z,ack=x+1,并进入到LAST-ACK状态。
    * 客户端接收到FIN报文后，发送ACK确认报文，首部标志位ACK=1,seq=x+1,ack=z+1,之后，客户端会进入TIME-WAIT状态，等待2MSL，之后进入CLOSED状态。
    * 服务端只要收到客户端最后一次的ACK报文就进入CLOSED状态。

* **31.	四次挥手时为什么客户端需要等待2MSL**
    * 为了保证客户端最后发送的ACK报文能够到达服务端。如果不等待2MSL，最后的ACK报文可能丢失，导致处于LAST-ACK状态的服务端无法正常关闭。而如果等待2MSL，服务端就会超时重传FIN报文，而客户端能够在2MSL时间勒收到重传信息，接着客户端重新发送ACK报文段，重启2MSL计时器。
    * 为了使旧的数据包在网络中因过期而消失。可能存在一些数据在传输中严重推迟的现象，而在推迟的数据到达前，发送方已重发该报文，并完成任务断开连接。随后又建立同IP、Port的连接，此时推迟的报文到达，此连接非彼连接，会发生数据错乱，导致无法预知的错误。因此，维持一段时间会使网络中所有的报文完全消失。

* **32.	如果已经建立连接，但客户端出现故障怎么办？**
    * TCP存有保活计时器，当服务端每次收到客户端请求时该计时器重置，如果时间达到2小时，服务端会每隔75s发送一次探测报文，默认发送9次。
    * 那么一次完整的保活探测需要时间为 ：7200s + 9 * 75s = 7875s，并且2小时是可以自己设定的。

* **33.	简述TCP的四种计时器？**
    * **重传计时器**:用于记录超时重传的时间，若在计时器截止时间前收到确认ACK报文则撤销此计时器，否则，重传该报文段，并将计时器复位。
    * **保活计时器**：用于双方长时间未通信而检测双方连接是否正常。
    * **时间等待计时器**：用于TCP最后一次挥手时，记录2MSL倒计时。
    * **持续计时器**：用于解决C/S双方通信时窗口大小为0的问题。
    > 假设当接收方发送窗口大小为0的信息，发送方就停止发送报文段，等待接收方宣布非0大小的窗口信息。如果该确认(非0大小窗口信息)丢失，那么发送方就会继续等待，而接收方会认为任务完成而等待发送方发送新的信息，双方处于死锁等待的情况。
    > 
    > 为了避免这种情况，发送方会在收到一个窗口大小为0的确认时，就启动持续计时器，时间归0时，发送方就会发送探测报文段，表示：确认信息已丢失，必须重传。
    > 
    > 若仍未收到接收方的响应，则需要继续发送探测报文段，并将计时器的值加倍和重置，重复这个过程知道增大到门限值（默认60s），此后按照60s发送探测报文段，直至窗口重新打开。

* **34.	简述超时重传时间的计算方式？**
    * RTT:往返时延，代表TCP发送方从发送报文段到接收到确认报文段的这段时间。
    * RTO:超时重传时间
    * 新的加权平均往返时间RTTs = 7/8 * 旧的RTTs + 1/8 * 当前的RTT样本
    * 新的RTTd = 3/4 * 旧的RTTd + 1/4 * |RTTs – 当前RTT样本|
    * RTO = RTTs + 4RTTd (RTTd为RTT偏移的加权平均值)

* **35.	如何强制断开TCP连接？**
    * 使用dsniff集成工具包的tcpkill命令
    * 将TCP报文中RST标志位置1
    * 操作系统提供的函数shutdown和closesocket

* **36.	简述什么是洪泛攻击？如何避免？**
    > SYN洪泛攻击主要是利用三次握手的缺陷。
    * **原理**：首先攻击者会向服务端发送SYN报文，而当服务端返回ACK报文时，攻击者并不进行确认，那么这个连接就处于挂起的状态。服务端由于一直收不到确认信息，会一直重传ACK报文，造成资源的浪费。那么如果攻击者对服务端发送大量非法的TCP连接，会导致服务器内存消耗殆尽而死机，这就是泛洪攻击，又名DoS攻击。
    * 避免方式：
        + 降低SYN timeout时间：使得主机尽快释放半连接的占用
        + 采用SYN cookie设置：短时间内重复收到同IP的请求，就默认受到攻击
        + 使用长连接：建立长连接的情况下，多次请求会使用已建立的连接的通道

* **37.	简述大量TIME-WAIT的危害？**
    * TIME-WAIT过多会占用内存，一个TIME-WAIT占用4K。
    * 对端口资源的占用，一个TCP连接至少消耗一个本地端口。而端口资源是有限的，一般可开启的端口为32768～61000，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接。

* **38.	TCP挥手可以三次吗？**
    * 不可以，首先第一次挥手不可能取消，那么对后面几次挥手情况进行考虑：
    * 如果将第二、三次合并为一次，由于第二次挥手后，服务端还有数据没有传输完毕，待数据传输完毕后才能第三次挥手，所以必须分开。
    * 第四次挥手是为了表示收到服务端请求断开连接的信息，此后，服务端才会断开连接，而不会出现第三次挥手信息丢失而导致客户端一直等待的情况。
    * 总之，四次挥手是双方经过协商确认对方想断开连接的过程，并不可省略。

* **39.	简述TCP可靠传输机制？**
    * **可靠传输**：就是保证数据的正确性，无差错、不丢失、不重复、按序到达保证可靠传输的方式：
    * **确认与重传**：接收方接收报文会确认，发送方未收到确认消息会重传报文段
    * **数据校验**：TCP可通过首部校验和验证报文段的准确性
    * **数据合理分片和排序**：TCP会按MTU分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。
    * **流量控制**：用于动态控制传输速率，防止数据丢失
    * **拥塞控制**：当网络拥塞时，对传输数据量进行调整

* **40.	TCP首部校验和如何验证？**
    * **作用**：接收端对校验和进行验证，有差错说明数据被改动，则直接丢弃。
    * **发送方检验和计算方式**：
        + 首先将校验和置0
        + 然后将TCP伪首部部分、TCP首部部分、数据部分都划分为16进制数
        + 将这些数逐个相加，溢出的部分加到最低位，循环加法
        + 最后将得到的结果取反，得到校验和
    * **接收方验证方式**：
        + 将所有数据以原码的方式相加，高位叠加，如果全为1，则正确

* **41.	简述TCP窗口控制原理？**
    * TCP利用滑动窗口来提高传输速度，意思是在一个窗口大小内，不用一定等待应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。
    * 如果不使用窗口控制，那么每一个没收到确认应答的数据都要重发，会严重影响传输速度，而使用窗口控制后，对于出现中间丢失的数据的情况，接收端会将该数据后的所有数据放入缓冲区，并会连续向发送方发送序号为丢失数据序号的响应，表示我需要接收该数据，如果发送方连续三次收到相同响应，就会立刻重发。
    * 如果中间时刻发送方收到接收方窗口大小为0的通知，则会启动持续计时器进行等待接收方的通知。

* **42.	简述TCP拥塞控制原理？**
    * 如果将窗口大小定的很大，发送端会连续发送大量的数据，可能会造成网络的拥堵，为了防止拥堵，需进行拥塞控制。
    * **四种拥塞控制算法**：
        + **慢启动**：最初发送报文段时，由于不清楚网络的负荷情况，先将拥塞窗口cwnd设置为一个最大报文段MSS的数值，每当收到确认应答后，就会将拥塞窗口加倍。此外还会设置慢开始的门限ssthresh变量，当cwnd>ssthresh后就会使用拥塞避免算法。
        + **拥塞避免**：缓慢的将拥塞窗口增大，即每经过一个往返时间RTT就将cwnd+1，按线性速度增长。中间如果拥塞现象，则会将门限值ssthresh设置为当前cwnd的一半，cwnd设为1，执行慢开始算法。
        + **快恢复**：当发送方连续收到三个重复确认，将门限值ssthresh减半，然后设置cwnd=ssthresh+3,开始拥塞避免算法。
        + **快速重传**：发送方只要收到三个重复确认就应当立即重传对方尚未收到的报文段，而无需等待重传计时器到期。

* **43.	为什么快速重传是3次冗余ACK？**
    * 主要考虑报文段的丢失是由于链路故障还是乱序等其他因素引发。
    * 连续两次ACK很有可能是乱序造成，三次ACK很有可能是丢包造成的。
    * 次数越多越有可能是丢包造成的，但是这种响应策略太慢，所以结合实践经验规定为3次。

* **44.	TCP握手时第一次的seq值如何随机生成？**
    * 第一次的序号是随机生成的，但也不是完全随机，使用的是ISN算法得到。
    * seq = C + H(源IP地址、目的IP地址、源端口、目的端口)其中C是计时器，每4ms增加1，H是信息摘要算法，输入的是四元组，需要通过某种hash方式得到。

* **45.	简述Nagle算法？**
    * **目的**：为了减少广域网的分组数目，通过减少网络发送包的数量来提高TCP传输效率，减少网络拥塞现象的出现。
    * 简单来说，当发送方得到数据时，并不立刻发送此段数据，而会等待一段时间，将时间接近的、数据量小的数据合并，进行封包处理，一同发送。
    * 并且，还有一个规定：要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组。

* **46.	简述TCP粘包现象产生的原因及解决方案？**
    * 由于Nagle算法造成的发送端粘包。
    * 接收端接收不及时导致的接收端粘包。接收方会将接收到的数据存于缓冲区，然后通知应用层程序读取数据，那么当应用层由于某些原因而不能及时取出数据时，就会造成TCP缓冲区存放多段数据。

    * **解决方法：**
        + 设置固定长度的报文、设置报文头部指示报文的长度、使用分隔符分割（常用\n）
        + 优化接收方接收数据过程，使其能及时接收数据，包括提高接收进程优先级等

* **47.	为什么UDP不会产生粘包现象？**
    * 对于UDP，不会使用块的合并优化算法，不存在封包的过程，另外，UDP本身是一个“数据包”协议，每段数据都有界限。并且从UDP头部可以得到数据包的长度。

* **48.	TCP四次挥手时出现大量CLOSE-WAIT的原因及解决方案？**
    * 服务器内部业务处理占用了过多时间，还没能处理完业务。可能因为还存在数据需要发送、服务端业务有逻辑。
    * 服务端的父进程派生出子进程，子进程继承了socket，当收到FIN的时候子进程处理但是父进程没有处理该信号，导致socket的引用不为0无法回收。
    
    * **处理方法：**
        + 停止应用程序
        + 修改程序里的bug

* **49.	端口的有效范围是多少？**
    * 0-1023是知名端口号，例如：http为80，DNS为53
    * 1024-65535为可拓展端口号，因为TCP、UDP存储的是16位端口号，故最大为65536

* **50.	三次握手哪次开始可以携带数据？**
    * 第三次握手可以携带数据，但前两次并不能携带数据。
    * 第一次如果携带数据的话，假如遭到网络攻击发送大量无用数据，这会造成服务端花费很多时间、空间来接受报文。
    * 第二次握手是服务端发送的ACK报文段，发送数据并没有什么作用。

* **51. 简述TCP接收/发送消息的底层过程？**
    * **数据发送：**
        + 调用send()发送。
        + 内核调用tcp_sendmsg()。
        + 复制按MSS分组的数据到内核态，复制到内核中的sk_buff结构来存放，同时把这些分片组成队列，放到这个TCP连接对应的tcp_write_queue发送队列中。
        + 缓存不足，send_timed时间内等待有空闲的缓存，超时或有空闲的缓存时继续复制MSS分组到内核态，，内核态为这个TCP连接分配的内核缓存有限，当没有多余的内核态缓存来复制用户态的待发送数据时，就需要调用sk_stream_wait_memory来等待滑动窗口移动，释放一些内存，即那些已被对方确认收到的数据。
        + 调用tcp_push方法， 按Nagle、慢启动等算法调用IP层来发送tcp_write_queue队列中的报文。
        + 发送方法返回（内核试图将消息发给对方，不确保发送到网络或发送给对方成功）。
    * **数据接收：**
        + 首先是PC上的网卡接收到网线传来的报文。通过软中断内核并且解析其为TCP报文，然后TCP模块决定如何处理这个TCP报文。
        + 用户进程调用read,recv等获取TCP消息，则是将网卡上的消息拷贝到用户进程里的内存里。


## 应用层
---

* **52.	简述HTTP的工作原理？**
    * HTTP协议采用的是请求/响应模型
    * 客户端向服务端发送请求报文，请求报文包含请求的方法、URI、协议版本、请求头部和请求数据。
    * 服务端返回一个状态行作为响应，响应的内容包括协议的版本、状态码、用于解释状态码的原因短语、响应头部、响应体。

* **53.	简述URL和URI的区别？**
    * URL：统一资源定位符，用于表示资源的位置
    * URI：统一资源标识符，用于标识资源
    * 因此URL是URI的子集

* **54.	简述HTTP协议无连接、无状态的含义？**
    * **无连接**：限制每次连接只处理一个请求。服务端处理完客户端的请求，并收到客户的应答后，即断开连接。这种方式可以节约传输时间。
    * **无状态**：指协议对于事务处理没有记忆能力，也就是不具备保存之前发送过的请求或响应的功能。这样是为了更快的处理大量事务，确保协议的可伸缩性。

* **55.	简述HTTP协议的特点？**
    * **支持客户/服务器模式**：HTTP协议规定，请求从客户端发出，然后服务端响应该请求并返回。
    * **简单快速**：客户端向服务端请求服务时，只需要传送请求的方法和路径。常用的请求方法有GET、HEAD、POST。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
    * **灵活**：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type（Content-Type是HTTP包中用来表示内容类型的标识）加以标记。
    * **无连接**：限制每次连接只处理一个请求。
    * **无状态**：指协议对于事务处理没有记忆能力。

* **56.	简述HTTP报文格式？**
    * **请求报文**：请求行、请求头、空行、请求体
        + 请求行：包含请求方法、URI、协议版本
        + 请求头部：包含多个key:val信息，如：Host（指定要请求的资源所在主机和端口）、Accept（告诉服务端，客户端接受什么类型的响应）、Referer（表示请求从哪个URL来）、Connection（连接方式keep-alive）、Content-Length（HTTP报文长度）、Content-Encoding（向服务端发送数据的编码类型，解码之后才能得到Connect-Type头指定的内容类型）、Cache-Control（缓存控制）等。
    * **响应报文**：响应行、响应头、空行、响应体
        + 响应行：包含协议版本、状态码、状态码的原因短语
        + 响应头部：包含多个key:val信息，如：Date（当前时间）、Server（服务端名称）、Allow（服务端支持哪些请求方法，如get、post）、Referer、Content-Length、Content-Type等。

* **57.	简述HTTP有哪些请求方法？**
    * **GET**：获取资源，请求指定信息，并返回实体主体
    * **POST**：传输实体主体，向指定资源提交数据进行处理请求
    * **HEAD**：获取报文首部，响应中无具体内容，用于获取报头
    * **PUT**：传输文件，从客户端向服务端传送的数据取代指定文档的内容
    * **DELETE**：删除文件，请求服务器删除指定的页面
    * **OPTIONS**：询问支持的方法，查询针对请求URI指定的资源支持的方法
    * **TRACE**：追踪路径，回显服务端收到的信号，主要用于测试或诊断
    * **CONNECT**：要求使用隧道协议连接代理，要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信
    > 为什么一般不使用put：由于在http1.1版本中的put方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般不使用。

* **58.	简述GET和POST的区别？**
    * GET会将请求放在URL后面，而POST会将请求放在报文体中。
    * 参数的数据类型不同，GET只接受ASCII编码，而POST无限制。
    * GET请求时URL长度会受到特定浏览器的限制，而POST无限制。
    * GET将请求放在URL后，并不安全，而POST放于报文体中，更加安全。
    * GET请求会被浏览器主动缓存，而POST不会，但可以手动设置。
    * GET请求时只会产生一个TCP数据包，浏览器会把header和data一起返回，服务端响应200，而POST会产生两个TCP数据包，先发送header信息服务端响应100，再发送data，服务端响应200。

* **59.	简述有哪些HTTP状态码？**
    * **1XX**：表示通知信息，接收的请求正在处理
        + 100：继续，客户端应重新发送初始请求，并在请求中附上第一次未提供的表示
        + 101：切换协议，服务端根据客户端请求切换协议，只能切换到更高级的协议
    * **2XX**：表示成功，请求正常处理完毕
        + 200：OK，表示客户端发来的请求在服务端被正常处理了
        + 204：表示请求处理成功，但没有资源可返回
        + 206：表示客户端进行了范围请求，而服务端成功执行请求，并放于Content-Range
    * **3XX**：表示重定向，需要进行附加操作以完成请求
        + 301：表示永久重定向，请求的资源已被分配新的URI，返回信息包含新的URI
        + 302：表示临时重定向，请求的资源被临时定位的其他位置
        + 303：表示临时重定向，同302，但明确表示客户端应当采用GET方法获取资源
        + 304：表示当客户端发送附带条件的请求时，服务端找到资源，但不符合条件请求
        + 307：表示临时重定向，会遵循浏览器标准，不会将GET变为POST
    * **4XX**：表示客户端出错，服务端无法处理请求
        + 400：表示客户端请求报文中存在语法错误
        + 401：表示请求需要有通过HTTP认证的认证信息，即需要进行身份认证
        + 403：表示请求被服务端拒绝，用户权限不够
        + 404：表示服务端无法找到请求的资源
    * **5XX**：表示服务端处理错误
        + 500：表示服务端处理请求内部错误，可能是Web应用的bug或者临时故障
        + 501：表示服务端不具备请求功能
        + 502：表示服务端作为网关或代理，从上游服务器收到无效响应
        + 503：表示由于超载或系统停机维护，服务端暂时无法处理客户端的请求
        + 504：表示作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器收到响应
        + 522：表示服务器连接超时

* **60.	简述HTTP1.1新特性？**
    * **长连接**：在一次TCP连接上可进行多次请求和响应，服务端会继续等待同域名下继续使用该TCP连接传输数据，减少了建立和关闭连接的消耗和时延。
    * **管线化**：客户端可以同时发送多个HTTP请求，而不用一个个等待响应。
    * **Host header**：客户端指定自己想访问的HTTP服务器的域名/IP和端口号。
    > 解决了一个IP对应多个域名的问题，使用方式是在请求报文首部中指定Host：IP
    > 
    > 如果无Host域，则服务端会返回400错误，且Host可以为空值。
    * **断点续传**：客户端记录下当前的下载进度，并在需要续传时通知服务器续传的位置。通俗讲，就是第一次未完全下载数据，第二次通过报文首部Range：XXXType，表示从固定位置开始继续下载，而不需要重新开始。
    * **缓存处理**：在HTTP1.0中主要通过header中的If-Modified-Since,Expires作为缓存的标准，而HTTP1.1中引入了更多的缓存控制策略，例如If-Match、Entity tag等更多可供选择的缓存头来控制缓存策略。

* **61.	简述HTTP1.1如何实现长连接？**
    * 在HTTP报文首部的Connection中，若字段中值为Keep-Alive，则使用长连接。
    * 如果Keep-Alive字段的值如Keep-Alive: timeout=15, max=100，则表示TCP通道最多可以保持15s，这个长连接最多处理100次请求就断开。

* **62.	简述HTTP2.0新特性？**
    * **多路复用**：允许同时通过单一的HTTP2.0连接发起多重请求-响应消息。
    * **二进制分帧**：在应用层和传输层之间增加二进制分帧层，将所有传输的信息采用二进制格式的编码分割为更小的消息和帧（frame），其中HTTP1.X的报文首部信息会被封装到HEADERS frame中，而相应的Request Body则封装到DATA frame中，改进传输性能。
    * **首部压缩**：由于HTTP1.X中每次发送相同请求时，头部字段会造成大量重复，因此在HTTP2.0中只会发送变化的首部字段，实现首部压缩。
    > 具体实现是通信双方共同维护头部信息表，所有字段都被记录，每次传输时只需要传送头在表中的索引（底层实现会使用哈夫曼编码）。
    * **服务端推送**：服务端会先于客户端检测到将要请求的资源，提前通知客户端，服务端不发送所有资源的实体，只发送资源的URL，客户端接到提示后会进行验证缓存，如果真需要这些资源，则正式发起请求（服务器主动更新静态资源）。

* **63.	简述管线化和多路复用的区别？**
    * 管线化技术可以使得一次发送多个请求，但是响应时也必须按顺序接收，即使后面的请求被处理完毕，也需要等待前面阻塞的请求，造成队头阻塞。
    * 多路复用技术复用TCP连接，各请求间不会相互影响。

* **64.	简述HTTP和HTTPS的区别？**
    * HTTP采用明文传输、而HTTPS采用安全的SSL/TLS加密传输协议。
    * HTTPS需要服务端申请CA证书，浏览器端安装根证书。
    * HTTP和HTTPS采用的连接方式完全不同，端口号也不同，前者为80，后者为443。
    * HTTPS除了需要进行三次握手外，还会进行SSL握手，协商加密使用对称密钥。
    * HTTP明确位于应用层，而HTTPS是HTTP+SSL/TLS，而SSL属于会话层协议（准确是位于传输层与应用层之间），因此HTTPS位于应用层+会话层。

* **65.	简述HTTPS协议的加密原理？**
    * HTTPS采用对称密钥和非对称密钥加密的方式，进行混合加密，两者有各自的优点。
    * 对称密钥加密处理速度快，但密钥无法安全的发送给对方。
    * 非对称密钥加密处理速度慢，但是密钥能够安全交换，如果将两种方式混合使用，就能实现互补。

* **66.	简述对称加密和非对称加密？**
    * **对称密钥加密**：加密和解密都使用相同的密钥。加密的同时也会将密钥发送给对方，发送过程中会导致密钥被窃取。
    * **非对称密钥加密**：非对称加密有两把密钥（私钥与公钥），私钥由自己保管，不能外泄，而公钥随意发放。发送密文时，使用对方的公钥进行加密，对方收到消息后，使用私钥解密。

* **67.	简述SSL协议的底层实现？**
    > SSL协议分为两层：SSL记录协议、SSL握手协议
    * **SSL记录协议**：建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。
    * **SSL握手协议**：建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

* **68.	简述SSL握手过程？**
    * 首先客户端发送请求，以明文的形式传送数据，其中包含自己支持的SSL版本、加密套件候选列表、压缩算法候选列表、用于生成密钥的随机数random_C等信息。
    * 服务端从支持的算法列表中选择一种加密算法，并将其和包含服务端公用密钥的证书、用于生成密钥的随机数random_S等信息发送给客户端。
    * 客户端验证证书的有效性，并且生成随机数Pre-master，并使用公钥加密，发送给服务端。
    * 此时服务端和客户端都获得三次随机数信息，通过加密算法得到协商密钥：enc_key。
    * 之后，客户端会将连接至今全部报文的整体校验值（之前所有通信参数的hash值）使用协商密钥加密，发送给服务端用于验证。
    * 服务端计算之前所有接收信息的hash值，并对客户端发来的数据进行解密，验证数据和密钥的正确性，之后服务端也会对其之前所有通信参数进行加密并发送。
    * 客户端计算之前所有接收信息的hash值，并对服务端发来的数据进行解密，验证数据和密钥的正确性，如果正确，则验证通过，握手完成。
    * 之后，双方通过协商密钥进行对称加密通信。

* **69.	简述数字证书的作用及内容？**
    * 数字证书是HTTPS实现安全传输的基础，由权威的CA机构颁发。
    * 证书内容包含：公钥、证书发布机构、证书有效期、签名算法、证书持有者、指纹及指纹算法等信息。

* **70.	简述如何验证数字证书有效性？**
    * 首先，从数字证书上可得到证书的颁发机构，然后需要去浏览器系统中寻找此颁发机构的根证书。
    * 由于根证书会预先嵌入浏览器中，如果未找到，说明该机构不受信任。
    * 接着，从根证书中得到根公钥，使用公钥解密此证书的数字签名，成功的话会得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的hash值，此外，还需要对当前证书内容使用指纹算法计算hash值，如果两次hash值相同，说明证书未被篡改。

* **71.	简述什么是自签名证书？**
    * 由自认证机构颁发的证书称为自签名证书。
    * 独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。
    * 当浏览器访问该浏览器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告信息。

* **72.	简述你对HTTP3.0的认识？**（扩展）
    * HTTP3.0采用的是**QUIC协议**，即**Quick UDP Internet Connections**，直译为快速UDP互联网连接。
    * QUIC使用的是HTTP2.0 + UDP，是一种基于UDP的低延时传输协议，其目的是解决采用传输层TCP协议存在的问题，同时满足传输层和应用层对多连接、低延时等的需求。
相比于之前的HTTP协议，主要的提升有：
    * 低延时连接：当客户端第一次连接服务端时，QUIC只需要1RTT时延就能建立安全可靠的连接（采用TLS1.3版本），相比于TCP + TLS的三次RTT更加便捷。之后，客户端可以在本地缓存加密的认证信息，当再次与服务端建立连接时可以实现0RTT（第一个包就可以发送数据）的连接建立延迟。
    * 队头阻塞问题：QUIC复用HTTP2.0协议的多路复用功能，又由于QUIC基于UDP，避免了TCP的队头阻塞问题，使得队头阻塞问题完全消除。
    * 前向安全机制：指密钥泄漏也不会让之前加密的数据被泄漏，只会对当前产生影响。原因是QUIC每次发送数据时都会通过公式计算不同的公钥。
    * 前向纠错机制：QUIC每发送一次数据就对这组数据进行异或运算，并将结果作为一个FEC包发送出去，接收方收到数据后，如果丢失某个包，则可以通过剩下的包和FEC包异或得到丢失的包，这样可以减少重传次数。
    * 连接迁移：由于TCP协议使用五元组（源IP，源Port，目的IP，目的Port，协议号）表示一个连接，每次进行网络切换时（4G切wifi），手机的IP地址就会改变，就必须创建新的TCP连接才能继续传输数据。
QUIC基于UDP摒弃了五元组的概念，使用64位随机数作为连接ID，网络切换时并不会重连，提高了业务层的体验。
* **73.	简述QUIC如何做到首次1RTT其余0RTT时延？**
    * QUIC首次连接需使用1RTT时间进行密钥交换，使用的交换算法为DH算法。（过程详细讲解位于：https://zhuanlan.zhihu.com/p/142794794 ）
    * QUIC非首次连接时由于客户端已经存在服务端的config文件，因此可以直接发送数据，使得时延达到0RTT。但是客户端保存的config是有时间限制的，失效之后仍需要进行首次连接时的密钥交换。

* **74.	简述DNS域名解析过程？**
    * 首先，浏览器会检查自身缓存是否解析过该域名的IP地址，如果有，则直接使用。
    * 如果浏览器缓存未命中，浏览器会对本地操作系统缓存中进行查找，即对本地hosts文件查找是否有解析过的结果。
    * 此后，还会在路由器的DNS缓存中查找是否有与之对应的IP映射。
    * 如果此时还未找到结果，才会真正开始请求本地域名服务器（LDNS），这是由网络服务提供商（ISP）提供的DNS服务器，当然，首先还是会对LDNS的缓存中查找结果。
    * 然后，本地DNS服务器会向根DNS服务器发送请求，如果域名后缀是.com，则会询问.com域名服务器的IP地址，得到后重复这个过程，依次会访问顶级域名服务器、一级域名服务器…，这个过程使用的是迭代的方式进行查询，最终会得到该域名的IP映射信息。
    * 最后LDNS会将IP信息返回给用户，用户会根据TTL值（域名解析信息在DNS存在的时间）将其存入本地系统缓存中，域名解析过程到此结束。

* **75.	简述DNS域名解析时递归和迭代的过程？**
    * **递归查询**：本机向本地DNS服务器发送查询请求后，就等待解析结果。而让本地DNS服务器向其他域名服务器查询获取最终IP，就是不需要自己查询，告诉自己的需求等待他人处理的过程。
    * **迭代查询**：迭代是本地DNS服务器向各域名服务器查询域名的过程，每次查询得到一个结果，再接着查询，类似于亲力亲为的过程。

* **76.	DNS使用的是TCP还是UDP？**
    * DNS规范规定了两种类型的DNS服务器（主DNS服务器、辅助DNS服务器）。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区域传送。
    * DNS进行域名解析时，使用的是UDP协议，因为查询域名时返回的内容一般都不超过512字节。这样DNS服务器的负载更低，响应更快。虽然从理论上说，客户端也可以指定向DNS服务器查询的时候使用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。
    * 辅助DNS服务器会定时（一般为3小时）向主域名服务器查询以便了解数据是否被更改。如果数据改动，则会进行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多很多，并且会超过UDP传输数据的范围。

* **77.	简述辅助DNS服务器的作用？**
    * DNS划分若干区域进行管理，每个区域由一个或多个域名服务器负责解析工作。多个域名服务器的好处是可以提供域名解析容错功能，对于多个域名服务器的区域，必须包含一台主域名服务器保存并管理整个区域的信息，其余的被称为辅助域名服务器。
    * 辅助DNS服务器无法对数据进行更改，只能通过修改主DNS服务器区域内容再更新到辅助DNS服务器，但在某些情况下，辅助DNS服务器可以将更改请求传递到主DNS服务器。
    * 使用的是主DNS服务器进行域名解析过程。
    * **辅助DNS服务器的作用**：
        + 提供区域冗余，能够在这个区域的主服务器停止响应的情况下为客户端解析这个区域的DNS名称。
        + 辅助DNS服务器可以减少区域主DNS服务器的负载。

* **78.	简述DNS负载均衡？**
    * 当一个网络中有足够多的用户时，假如每次请求的资源都位于同一台机器上，那么这台机器很容易处于满负荷工作的状态，从而使得服务器崩溃，那么解决的办法就是使用DNS负载均衡技术。
    * DNS负载均衡的原理是：为同一个域名分配多个IP，每个IP对应不同的主机，由于在使用DNS域名解析的时候，大多数客户端会使用第一个收到的IP表示域名，那么，只需要设定每次请求都会返回不同顺序的IP列表即可。这样就可以将多次请求分配到不同IP对应的服务器进行数据查询，使得请求的流量分散，减少服务器的压力。

* **79.	简述服务器高并发的解决方案？**
    * **应用数据与静态资源分离**：将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。
    * **客户端缓存**：因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。
    * **集群和分布式**：（集群是所有的服务器都有相同功能，请求哪台都可以，主要起分流作用）、（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器。同时加快请求处理的速度。
    * **反向代理**：在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端，缓解服务器的压力。

* **80.	简述代理服务器的作用？**
    * 提高访问速度：由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门站点能明显提高请求速度。
    * 防火墙的作用：由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可在代理服务器上设限，过滤某些不安全信息。
    * 通过代理服务器访问不能访问的目标站点：互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，虽然不能出国，但也可直接访问外网。

* **81.	简述输入URL执行的全过程？**
    * 首先在应用层会使用DNS进行域名解析，得到对应域名的IP地址。
    * 应用层生成HTTP请求报文，报文首部可能包含host、keep-alive、User-Agent、Accept-Encoding、Accept-Language等信息。
    * 传输层建立TCP连接（因为HTTP使用的TCP协议），使用本地一个大于1024的随机TCP端口建立到服务端TCP80号（HTTPS为443端口，并且默认先使用80）端口的连接，端口号信息存储于TCP报文首部中。
    * 网络层使用IP协议选择路线，即可能包含路由选择功能等。
    * 数据链路层实现网络相邻结点的可靠数据通信，将数据包封装成帧，由于可能会发生数据丢失和出错，中间会使用CRC（循环冗余校验）的方式保证数据正确性。当然中间会涉及到ARP协议。
    * 物理层实现数据的真正传输，将帧转化成二进制的比特流，通过物理器件传输。
    * 服务端收到比特流后，对数据向上进行一层层处理，最后将数据传到服务器的应用层，服务端会对其请求进行响应，按照上述过程返回给客户端。
    * 当客户端收到服务端的响应报文后，如果返回的是301或302重定向信息，则浏览器会使用相应头中的location再次发送请求。如果不是，则会对响应中的html代码进行解析，并请求html代码中的资源（如js,css图片等）。
    * 如果HTTP协议未使用长连接的方式，则此时会四次挥手断开TCP连接。
    * 最后，浏览器对页面进行布局和渲染呈现给用户。

* **82.	简述HTTP与TCP中Keep-Alive的不同？**
    * TCP中的Keep-Alive是指TCP保活计时器，作用是当通信双方长时间为交互通信，就会检测对方的状态，如果异常就会断开连接，节约资源。
    * HTTP中的Keep-Alive是指HTTP1.1开始使用的长连接的方式，在HTTP请求头部字段中写入是否需要进行长连接，以保证同一次TCP连接可以用来发送多个HTTP请求，实质是TCP是否长连接。

* **83.	简述Cookie及其原理？**
    * Cookie的出现是由于HTTP协议是一种无状态的协议，会导致每刷新一次页面就会重新要求输入账号密码，因此使用Cookie来对浏览器身份进行标识。
    * Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器向服务器发送请求时被携带上，用于告知服务端两个请求来自同一浏览器。
    * 由于每次发送请求需要携带Cookie数据，会带来额外的性能开销，但是现在，逐渐有其它方式替代Cookie。
* **84.	简述Cookie有哪些具体用途？**
    * 会话状态管理，如用户登录状态、购物车、游戏分数等需要记录的信息。
    * 个性化设置，如用户自定义设置、主题等。
    * 浏览器行为跟踪，如跟踪分析用户行为等。

* **85.	简述Session及其原理？**
    * 除了将信息存储于浏览器中，还可以使用Session存储于服务端、数据库、内存中，这样的存储方式会更加安全。
    * **实现原理**：
        + 当客户端将账号密码放入请求报文中发送给服务端时，服务端会根据其创建Session ID（可能为将账号密码存入数据库的key），并发送给客户端，客户端会将Session ID利用Cookie存入浏览器。
        + 客户端之后每次请求服务器都会携带Session ID，服务端收到Session ID后在内存或数据库中查找对应数据就可正常使用了。

* **86.	简述Cookie和Session的区别？**
    * Cookie存在于客户端（浏览器），Session存在于服务端。
    * Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，而Session是在服务端的一种数据结构。
    * Session的运行依赖Session ID，而Session ID存储于Cookie中，也就是说如果浏览器禁用了Cookie，那么Session也会失效，但是也可以使用其它方式实现，比如在URL中传递Session ID。

* **87.	简述针对Web应用的两种攻击模式？**
    * **主动攻击**：是指攻击者通过直接访问Web应用把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此可以直接得到需要的资源。
    * **被动攻击**：是指利用圈套策略执行攻击代码的攻击模式。攻击者不直接对目标Web应用发起攻击，而是使用户落入设定的陷阱，以获取资源的方式。

* **88.	简述有哪些常见的网络攻击方式？**
    * **SQL注入**：是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。
    * **XSS**：跨站脚本攻击，是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击，属于被动攻击。
    * **OS命令注入攻击**：是指通过Web应用，执行非法的操作系统命令达到攻击的命令。
    * **CSRF**：跨站点请求伪造攻击，是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。
    * **DoS**：是一种让运行中的服务呈停止状态的攻击，主要方式包括集中利用访问请求造成资源过载，资源用尽的同时，服务就呈停止状态。
    * **点击挟持**：是指利用透明的按钮或链接做成陷阱，覆盖于Web页面之上，然后诱使用户在不知情的情况下，点击链接访问内容的一种攻击手段。
    * **会话固定攻击**：是指强制用户使用攻击者指定的会话ID，属于被动攻击。
        + 攻击过程：攻击者准备陷阱，先访问服务器得到Session ID，而且目前处于未认证的状态，然后攻击者强制用户使用该ID去认证。之后攻击者再使用该认证后的ID去登陆网站访问数据。

* **89.	简述SQL注入攻击的影响？**
    * 非法查看和修改数据库内的数据
    * 规避认证
    * 执行和数据库服务器业务关联的程序等

* **90.	如何防范CSRF攻击？**
    * **Token机制**：在HTTP请求时增加token，进行token验证，如果请求中无token或token内容不正确，则认为是CSRF攻击。
    * **Referer识别**：在HTTP请求报文中有Referer字段，用于记录HTTP请求的来源地址，但由于用户保护隐私的考虑，很多情况下都限制了Referer的发送。
    * **双重Cookie验证**：在请求前读取Cookie值，并在请求时加入URL，在服务端会对请求报文中Cookie 值 和URL的Cookie验证是否相等。因为CSRF攻击只能修改请求中的Cookie值，不能读取URL的值。

* **91.	简述IPv6的邻居发现协议NDP？**
    * 在IPv4中使用ARP协议进行IP地址到MAC地址的映射，在IPv6中由NDP邻居发现协议完成此项任务。
    * Host A在向Host B发送报文之前它必须要解析出Host B的链路层地址，所以首先Host A会发送一个NS报文，其中源地址为Host A的IPv6地址，目的地址为Host B的被请求节点组播地址，需要解析的目标IP为Host B的IPv6地址，这就表示Host A想要知道Host B的链路层地址。同时需要指出的是，在NS报文的Options字段中还携带了Host A的链路层地址。
    * 当Host B接收到了NS报文之后，就会回应NA报文，其中源地址为Host B的IPv6地址，目的地址为Host A的IPv6地址（使用NS报文中的Host A的链路层地址进行单播），Host B的链路层地址被放在Options字段中。这样就完成了一个地址解析的过程。

* **92.	简述ARP攻击的原理？**
    * **原理**：同局域网下，攻击方类似于中间代理，通过伪造IP获得通信双方的信息，并且伪造身份使得通信双方认为攻击方是真正的另一方。
    * 不同局域网下，攻击方通过伪装网关身份进行ARP攻击。

* **93.	简述TCP第三次挥手时若FIN包比之前传送的数据先到达会如何处理？**
    * 首先，答案是会接收并处理。
    * 实际发送数据时，数据报的序列号seq是有序的，也就是说我们最后一次数据报文的seq值等于发送的FIN报文的seq值 -1，因此，当我们优先接收到FIN报文时，发现seq值乱序，会被放入乱序队列中，等待需要的seq值到达。
    * 当FIN报文放入乱序队列中，每次接收数据报文，会优先检查seq是否正确，然后才会判断是否是FIN报文，因此，这个机制下会处理该迟到报文。
    * 最后，乱序队列的底层实现是红黑树。

* **94.	HTPP请求方法中POST可以在URL携带参数吗？**
    * 可以，可以在URL和body体同时携带参数。

* **95.	简述MSL和TTL的区别？**
    * MSL指报文最大生存时间，超过这个时间的报文就会被丢弃。
    * TTL是位于IP头部的字段，同样指最大生存时间，但指的是最大的路由跳转数量，由源主机设置初值，每经过一个路由就会-1。
    * MSL需要大于等于TTL。

* **96.	ip数据包经由路由转发的时候源ip，目的ip是否改变？**
    * 一般情况下不能改变，除非进行了NAT协议转换。
    * 但是mac地址是变化的，因为发送端开始不知道目的主机的mac地址，所以每经过一个路由器mac地址是变化的。

* **97.	简述DHCP协议的作用？**
    * DHCP名为动态主机分配协议，是一个局域网的网络协议，使用的是UDP协议工作，统一使用两个端口分配：67（服务端）、68（客户端）。
    * DHCP通常使用于局域网环境，主要作用是集中的管理、分配IP地址，使client动态获取IP地址等，并能够提高地址的使用率。简单说，DHCP是一个不需要账号密码登录、自动给内网机器分配IP地址等信息的协议。
    * **DHCP报文种类（8种）**：
        * **Discover**：DHCP客户端在请求IP地址时并不知道DHCP服务器的位置，因此DHCP客户端会在本地网络内以广播方式发送Discover请求报文，以发现网络中的DHCP服务器。所有收到Discover报文的DHCP服务器都会发送应答报文，DHCP客户端据此可以知道网络中存在的DHCP服务器的位置。
        * **Offer**：DHCP服务器收到Discover报文后，就会在所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息（如网关、DNS服务器等），构造一个Offer报文，发送给DHCP客户端，告知用户本服务器可以为其提供IP地址。但这个报文只是告诉DHCP客户端可以提供IP地址，最终还需要客户端通过ARP来检测该IP地址是否重复。
        * **Request**：DHCP客户端可能会收到很多Offer请求报文，所以必须在这些应答中选择一个。通常是选择第一个Offer应答报文的服务器作为自己的目标服务器，并向该服务器发送一个广播的Request请求报文，通告选择的服务器，希望获得所分配的IP地址。另外，DHCP客户端在成功获取IP地址后，在地址使用租期达到50%时，会向DHCP服务器发送单播Request请求报文请求续延租约，如果没有收到ACK报文，在租期达到87.5%时，会再次发送广播的Request请求报文以请求续延租约。
        * **ACK**：DHCP服务器收到Request请求报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录，如果有则发送ACK应答报文，通知用户可以使用分配的IP地址。
        * **NAK**：如果DHCP服务器收到Request请求报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则向DHCP客户端发送NAK应答报文，通知用户无法分配合适的IP地址。
        * **Release**：当DHCP客户端不再需要使用分配IP地址时（一般出现在客户端关机、下线等状况）就会主动向DHCP服务器发送RELEASE请求报文，告知服务器用户不再需要分配IP地址，请求DHCP服务器释放对应的IP地址。
        * **Decline**：DHCP客户端收到DHCP服务器ACK应答报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则会向DHCP服务器发送Decline请求报文，通知服务器所分配的IP地址不可用，以期获得新的IP地址。
        * **Inform**：DHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则向DHCP服务器发送Inform请求报文；DHCP服务器在收到该报文后，将根据租约进行查找到相应的配置信息后，向DHCP客户端发送ACK应答报文。目前基本上不用了。
